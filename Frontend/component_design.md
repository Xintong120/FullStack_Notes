# 外观

### 变体设计（Variants）

### **概念：**

同一个组件的不同**视觉风格**，功能相同但外观不同。

### **目的：**

- 区分不同的语义（主要、次要、危险等）
- 保持组件统一性，避免创建多个相似组件

### **常见变体类型：**

| 变体名          | 用途     | 视觉特征           | 使用场景         |
| :-------------- | :------- | :----------------- | :--------------- |
| **primary**     | 主要操作 | 蓝色背景，白色文字 | 提交、确认、保存 |
| **secondary**   | 次要操作 | 灰色背景，白色文字 | 取消、返回       |
| **destructive** | 危险操作 | 红色背景，白色文字 | 删除、清空       |
| **outline**     | 轮廓按钮 | 透明背景，边框     | 非强调操作       |
| **ghost**       | 幽灵按钮 | 透明背景，无边框   | 导航、链接式按钮 |
| **link**        | 链接样式 | 下划线文字         | 文字链接         |

### **设计原则：**

```
同一个Button组件 + 不同variant prop = 不同外观
而不是：PrimaryButton、SecondaryButton、DangerButton...
```

**优势：**

- ✅ 减少组件数量
- ✅ API统一
- ✅ 易于维护

## 尺寸变体（Size Variants）

### **概念：**

同一个组件的不同**大小规格**。

### **常见尺寸：**

| 尺寸     | 高度 | 内边距      | 字体 | 使用场景          |
| :------- | :--- | :---------- | :--- | :---------------- |
| **sm**   | 32px | px-3 py-1.5 | 14px | 紧凑布局、表格内  |
| **md**   | 40px | px-4 py-2   | 16px | 默认尺寸、表单    |
| **lg**   | 48px | px-6 py-3   | 18px | 重要操作、首页CTA |
| **icon** | 36px | 正方形      | -    | 纯图标按钮        |

### **设计原则：**

```
尺寸应该符合视觉节奏（通常是8px的倍数）
不同尺寸保持视觉权重一致
```

**示例对比：**

```
小按钮：适合工具栏
中按钮：适合表单
大按钮：适合首页行动号召
```



## has-[>svg]（CSS选择器）

### **概念：**

检测组件**是否包含特定子元素**，动态调整样式。

### **语法解释：**

| 选择器            | 含义               | 示例                       |
| :---------------- | :----------------- | :------------------------- |
| `has-[>svg]`      | 直接子元素是svg    | `<Button><svg /></Button>` |
| `has-[>svg]:px-3` | 有svg时改变padding | 图标按钮的间距调整         |

### **实际用途：**

```
普通按钮：px-4 (左右16px内边距)
有图标按钮：px-3 (减少到12px，因为图标占空间)
```

### **设计思路：**

```
自动检测 → 自动调整
用户不需要手动指定 iconButton={true}
组件智能判断内容，自动优化间距
```

**为什么这样设计：**

- ✅ 减少props（不需要 `hasIcon` prop）
- ✅ 自动化（组件自己判断）
- ✅ 灵活（任何SVG都能检测）



# 状态

## disabled状态（Disabled State）

### **概念：**

组件处于**不可交互**状态的视觉和功能表现。

### **三个层面：**

| 层面       | 作用         | 实现                  |
| :--------- | :----------- | :-------------------- |
| **功能层** | 阻止点击事件 | `disabled` HTML属性   |
| **视觉层** | 降低透明度   | `opacity: 0.5`        |
| **交互层** | 改变鼠标指针 | `cursor: not-allowed` |

### **设计原则：**

```
禁用 ≠ 隐藏
禁用状态应该让用户知道：
1. 这个功能存在
2. 但现在不能用
3. （可选）为什么不能用
```

**何时使用：**

- 表单验证未通过
- 加载/处理中
- 权限不足
- 业务逻辑限制

##  focus状态（Focus State）

### **概念：**

组件获得**键盘焦点**时的视觉反馈。

### **重要性：**

| 用户群体     | 依赖focus状态的原因           |
| :----------- | :---------------------------- |
| **键盘用户** | 用Tab键导航，需要知道焦点在哪 |
| **视障用户** | 屏幕阅读器依赖焦点顺序        |
| **所有用户** | 提升可用性和可访问性          |

### **设计层次：**

| 类型             | TailwindCSS      | 何时触发 | 用途          |
| :--------------- | :--------------- | :------- | :------------ |
| `:focus`         | `focus:`         | 任何聚焦 | 所有聚焦情况  |
| `:focus-visible` | `focus-visible:` | 键盘聚焦 | 只在Tab时显示 |

### **常见样式：**

```
focus-visible:ring-2        (外圈光晕)
focus-visible:ring-blue-500 (蓝色光圈)
focus-visible:outline-none  (移除默认轮廓)
```

**设计原则：**

```
焦点状态应该明显但不突兀
鼠标点击不显示（focus-visible）
键盘导航必须显示
```

# 扩展性

## 组合类名（ClassName Composition）

### **概念：**

允许使用者**额外添加**自定义样式，而不覆盖组件原有样式。

### **实现方式：**

```jsx
// 方式1：模板字符串拼接
className={`${baseStyles} ${variants[variant]} ${className}`}

// 方式2：工具函数（clsx/cn）
className={cn(baseStyles, variants[variant], className)}
```

### **为什么重要：**

| 场景         | 说明             | 示例                                    |
| :----------- | :--------------- | :-------------------------------------- |
| **布局调整** | 外部控制间距     | `<Button className="mt-4">`             |
| **响应式**   | 不同屏幕不同样式 | `<Button className="w-full md:w-auto">` |
| **特殊情况** | 个别页面特殊需求 | `<Button className="animate-pulse">`    |

### **设计原则：**

```
内部样式 + 外部样式 = 最终样式
外部样式应该能增强，不应该破坏基础功能
```

**反模式：**

```jsx
❌ 错误：只用外部className，忽略内部样式
className={className}  // 会丢失所有基础样式

✅ 正确：合并
className={`${baseStyles} ${className}`}
```



## Slot（插槽/多态组件）

### **概念：**

允许组件渲染为**不同的HTML元素**，但保持样式和行为。

### **来源：**

```
@radix-ui/react-slot 库
React的多态组件模式
```

### **问题场景：**

```jsx
// 问题：按钮想要跳转到其他页面
<Button onClick={() => navigate('/home')}>  ❌ 不好：刷新页面
    首页
</Button>

// 理想方案：
<Button asChild>                           ✅ 好：变成<a>标签
    <a href="/home">首页</a>
</Button>
```

### **核心机制：**

| 场景     | asChild | 实际渲染   | 用途     |
| :------- | :------ | :--------- | :------- |
| 普通按钮 | false   | `<button>` | 触发事件 |
| 链接按钮 | true    | `<a>`      | 页面跳转 |
| Next.js  | true    | `<Link>`   | 路由跳转 |

### **工作原理：**

```jsx
const Comp = asChild ? Slot : "button"
// asChild=false → 渲染 <button>
// asChild=true → 渲染子元素（但应用Button样式）
```

**Slot的魔法：**

```
1. 获取子元素（如<a>）
2. 把Button的className合并到<a>上
3. 把Button的props合并到<a>上
4. 最终<a>看起来像Button，但行为是链接
```

##  asChild（作为子元素）

### **概念：**

配合Slot使用的prop，告诉组件"把样式应用到子元素上"。

### **使用对比：**

| 写法                                                | asChild | 渲染结果                                     | 语义           |
| :-------------------------------------------------- | :------ | :------------------------------------------- | :------------- |
| `<Button>文字</Button>`                             | false   | `<button>文字</button>`                      | 按钮           |
| `<Button asChild><a href="/">文字</a></Button>`     | true    | `<a href="/" class="button-styles">文字</a>` | 链接（像按钮） |
| `<Button asChild><Link to="/">文字</Link></Button>` | true    | `<Link class="button-styles">`               | 路由（像按钮） |

### **深层原理：**

```
传统方式：
<Button> → 只能是 <button> → 限制大

多态方式：
<Button asChild> → 可以是任何元素 → 灵活
```

### **何时使用：**

| 场景     | 是否用asChild | 原因                |
| :------- | :------------ | :------------------ |
| 提交表单 | ❌ 不需要      | 用原生`<button>`    |
| 外部链接 | ✅ 需要        | `<a href>` 更语义化 |
| 路由跳转 | ✅ 需要        | 配合`<Link>`        |
| 下载文件 | ✅ 需要        | `<a download>`      |

### **设计哲学：**

```
组件的样式 ≠ 组件的DOM元素
样式可以复用在不同元素上
```

## 📊 8个概念的关系图

```
┌─────────────────────────────────────┐
│         Button 组件                  │
├─────────────────────────────────────┤
│                                      │
│  【外观】                             │
│  ├─ 变体设计 (variant: primary/...)│
│  ├─ 尺寸变体 (size: sm/md/lg)      │
│  └─ 自动调整 (has-[>svg])          │
│                                      │
│  【状态】                             │
│  ├─ disabled (不可用)               │
│  └─ focus (键盘焦点)                │
│                                      │
│  【扩展性】                           │
│  ├─ 组合类名 (接受外部className)    │
│  ├─ Slot (多态能力)                 │
│  └─ asChild (变身其他元素)          │
│                                      │
└─────────────────────────────────────┘
```



## 前端背景颜色排查通用教训

### 问题现象

页面背景显示为意外的颜色（比如亮黄色），即使在代码中看起来设置了白色或浅灰色背景。

### 根本原因

现代前端开发中，背景颜色的设置层级可能很复杂：

1. **CSS 变量系统**：Tailwind CSS 使用 HSL 颜色变量（如 `--background: 250 250 250`），这些变量可能在不同显示器/浏览器中渲染出不同的颜色
2. **组件层级覆盖**：多个组件层级可能都有背景设置，底层组件可能被覆盖
3. **Tailwind 类优先级**：`bg-background` 依赖 CSS 变量，而直接的 `bg-white` 更直接

### 排查步骤

1. **检查开发者工具**：查看元素的 Computed 样式，确认实际应用的 background 值
2. **逐步排查组件**：从根组件开始，检查每个有背景设置的元素
3. **测试颜色变量**：临时修改 CSS 变量值为极端值（如黑色）来验证修改是否生效
4. **使用直接颜色类**：优先使用 `bg-white`、`bg-black` 等直接颜色类，而不是依赖变量的 `bg-background`

### 解决方案优先级

1. **直接颜色类**（推荐）：`bg-white` 而不是 `bg-background`
2. **CSS 变量修改**：直接修改 `--background` 的值
3. **强制样式**：使用 `!important` 强制覆盖
4. **组件级覆盖**：在具体组件中设置背景而不是依赖全局变量

### 预防措施

- 在设计系统时优先使用直接颜色而不是复杂的变量系统
- 定期在不同设备和浏览器上测试颜色显示
- 为颜色变量设置明确的 fallback 值

这个教训适用于所有现代前端框架使用 Tailwind CSS 或类似设计系统的项目。

