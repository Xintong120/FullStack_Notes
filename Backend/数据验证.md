### 1. 基础概念 (Core Concepts)

#### BaseModel类

> 通过类型注解来定义字段应该是什么类型。
>
> 作用：
>
> - **验证数据类型**：确保传入的数据匹配定义的类型
> - **提供默认值**：如果字段有默认值，会自动填充
> - **序列化**：可以将对象转换为字典或JSON
> - **文档生成**：自动生成API文档

```python
from pydantic import BaseModel
from typing import Optional 
#Optional表示"可选的"，意思是这个字段可以是指定类型，也可以是`None`。

class User(BaseModel):
    # 这里定义字段和它们的类型
    name: str        # 字符串类型，必需字段：必须提供
    age: Optional[int] = None    # 可选字段：可以不提供，默认为None
    height: float    # 浮点数类型
    is_active: bool  # 布尔类型
    avatar: Optional[str] = None # 可选字段：可以不提供，默认为None

# 使用
user = User(id=1, name="张三", email="zhangsan@example.com")
print(user.name)  # 张三
print(user.dict())  # {'id': 1, 'name': '张三', 'email': 'zhangsan@example.com', 'age': None}
```

#### 基本数据类型
```python
from pydantic import BaseModel
from typing import List, Dict, Set 
#容器类型注解，用来描述包含其他数据的复合类型

class Article(BaseModel):
    title: str                    # 字符串
    content: str                  # 字符串
    views: int = 0               # 整数，默认值
    is_published: bool = False    # 布尔值
    tags: List[str] = []         # 字符串列表
    metadata: Dict[str, str] = {} # 字典
    categories: Set[str] = set()  # 集合
```



#### 完整的类型注解示例

```python
from pydantic import BaseModel, Field
from typing import Optional, List, Dict, Set
from datetime import datetime

class CompleteUser(BaseModel):
    # 基本类型
    id: int
    name: str
    email: str
    
    # 可选类型
    age: Optional[int] = None
    bio: Optional[str] = None
    
    # 容器类型
    tags: List[str] = []
    settings: Dict[str, str] = {}
    permissions: Set[str] = set()
    
    # 复杂类型
    profile: Dict[str, Optional[str]] = {}
    created_at: datetime = Field(default_factory=datetime.utcnow)
    
    # 嵌套模型
    addresses: List[Dict[str, str]] = []

# 使用示例
user = CompleteUser(
    id=1,
    name="张三",
    email="zhangsan@example.com",
    age=25,
    tags=["开发者", "Python"],
    settings={"theme": "dark", "notifications": "on"},
    permissions={"read", "write"},
    addresses=[
        {"type": "home", "street": "中山路100号"},
        {"type": "work", "street": "南京路200号"}
    ]
)

print(user.dict())
```

### 常用的typing导入

```python
from typing import (
    # 基本类型
    Optional,      # 可选类型
    Union,         # 联合类型
    
    # 容器类型
    List,          # 列表
    Dict,          # 字典  
    Set,           # 集合
    Tuple,         # 元组
    
    # 泛型
    TypeVar,       # 类型变量
    Generic,       # 泛型类
    
    # 特殊类型
    Any,           # 任意类型
    Callable,      # 可调用类型
    Awaitable,     # 异步类型
)
```



### 2. 字段验证 (Field Validation)

#### 约束验证
```python
from pydantic import BaseModel, Field, EmailStr, HttpUrl
from typing import Optional
from datetime import datetime

class Product(BaseModel):
    name: str = Field(..., min_length=1, max_length=100)
    price: float = Field(..., gt=0, le=10000)  # 大于0，小于等于10000
    description: Optional[str] = Field(None, max_length=500)
    email: EmailStr  # 自动验证邮箱格式
    website: Optional[HttpUrl] = None  # 自动验证URL格式
    created_at: datetime = Field(default_factory=datetime.utcnow)
    
    # 正则表达式验证
    sku: str = Field(..., regex=r'^[A-Z]{2}\d{6}$')  # 如 AB123456
```

#### 自定义验证器
```python
from pydantic import BaseModel, validator, ValidationError
from typing import List

class UserCreate(BaseModel):
    username: str
    password: str
    confirm_password: str
    tags: List[str] = []
    
    @validator('username')
    def username_valid(cls, v):
        if not v.isalnum():
            raise ValueError('用户名只能包含字母和数字')
        if len(v) < 3:
            raise ValueError('用户名至少3个字符')
        return v
    
    @validator('password')
    def password_strength(cls, v):
        if len(v) < 8:
            raise ValueError('密码至少8位')
        if not any(c.isupper() for c in v):
            raise ValueError('密码必须包含大写字母')
        return v
    
    @validator('confirm_password')
    def passwords_match(cls, v, values):
        if 'password' in values and v != values['password']:
            raise ValueError('两次密码不一致')
        return v
    
    @validator('tags', each_item=True)
    def validate_tags(cls, v):
        if len(v) > 20:
            raise ValueError('单个标签不能超过20字符')
        return v.strip()
```

### 3. 数据转换 (Data Conversion & Parsing)

#### JSON解析和序列化
```python
# 自动解析JSON
json_data = '{"name": "张三", "age": "25"}'  # age是字符串
user = User(**json.loads(json_data))  # 自动转换为int

# 序列化为JSON
user_dict = user.dict()  # 转换为字典
json_str = user.json()   # 转换为JSON字符串

# 排除字段
user.dict(exclude={'password'})  # 排除密码字段
user.dict(include={'name', 'email'})  # 只包含指定字段
```

#### 自定义类型
```python
from pydantic import BaseModel
from enum import Enum

class UserRole(str, Enum):
    ADMIN = "admin"
    USER = "user"
    GUEST = "guest"

class Color:
    def __init__(self, hex_value: str):
        if not hex_value.startswith('#'):
            hex_value = f'#{hex_value}'
        self.hex_value = hex_value.upper()
    
    def __str__(self):
        return self.hex_value

class Product(BaseModel):
    name: str
    role: UserRole  # 枚举类型
    color: Color    # 自定义类型
    
    class Config:
        # 自定义JSON编码器
        json_encoders = {
            Color: str  # Color对象序列化为字符串
        }

# 使用
product = Product(
    name="iPhone", 
    role=UserRole.USER,
    color=Color("FF0000")
)
print(product.color)  # #FF0000
```

#### 嵌套模型
```python
class Address(BaseModel):
    street: str
    city: str
    country: str

class Company(BaseModel):
    name: str
    address: Address

class User(BaseModel):
    name: str
    company: Company

# 嵌套数据自动验证
user_data = {
    "name": "张三",
    "company": {
        "name": "ABC公司",
        "address": {
            "street": "中山路100号",
            "city": "上海",
            "country": "中国"
        }
    }
}

user = User(**user_data)
```

### 4. 高级特性 (Advanced Features)

#### 模型配置
```python
class User(BaseModel):
    name: str
    email: str
    
    class Config:
        # 允许任意字段
        extra = 'allow'  # 'ignore', 'forbid', 'allow'
        
        # 字段别名
        allow_population_by_field_name = True
        
        # 验证失败时收集所有错误
        validate_all = True
        
        # 自定义字段序列化器
        json_encoders = {
            datetime: lambda v: v.timestamp()
        }
        
        # 字段排序
        fields = {
            'name': {'title': '姓名'},
            'email': {'title': '邮箱'}
        }
```

#### 泛型支持
```python
from typing import TypeVar, Generic
from pydantic.generics import GenericModel

DataT = TypeVar('DataT')

class Response(GenericModel, Generic[DataT]):
    success: bool
    data: DataT
    message: str = ""

# 使用泛型
user_response = Response[User](success=True, data=user, message="获取成功")
product_response = Response[Product](success=True, data=product)
```

#### 继承和组合
```python
class BaseEntity(BaseModel):
    id: int
    created_at: datetime = Field(default_factory=datetime.utcnow)
    updated_at: datetime = Field(default_factory=datetime.utcnow)

class User(BaseEntity):
    name: str
    email: str

class Article(BaseEntity):
    title: str
    content: str
    author_id: int

# 继承自动包含父类字段
user = User(id=1, name="张三", email="zhangsan@example.com")
article = Article(id=1, title="标题", content="内容", author_id=1)
```

### 5. 错误处理 (Error Handling)

#### ValidationError异常
```python
from pydantic import ValidationError

try:
    user = User(name="", email="invalid-email", age=-5)
except ValidationError as e:
    # 详细的错误信息
    print(e.errors())
    """
    [
        {
            'loc': ('name',),
            'msg': 'ensure this value has at least 1 characters',
            'type': 'value_error.any_str.min_length',
            'ctx': {'limit_value': 1}
        },
        {
            'loc': ('email',),
            'msg': 'value is not a valid email address',
            'type': 'value_error.email'
        },
        {
            'loc': ('age',),
            'msg': 'ensure this value is greater than or equal to 0',
            'type': 'value_error.const',
            'ctx': {'limit_value': 0}
        }
    ]
    """
```

#### 自定义错误处理
```python
def handle_validation_error(e: ValidationError) -> dict:
    """转换Pydantic错误为用户友好的格式"""
    errors = {}
    for error in e.errors():
        field = '.'.join(str(loc) for loc in error['loc'])
        
        # 自定义错误消息
        if error['type'] == 'value_error.email':
            message = "邮箱格式不正确"
        elif 'min_length' in error['type']:
            message = f"最少需要{error['ctx']['limit_value']}个字符"
        else:
            message = error['msg']
        
        errors[field] = message
    
    return {"success": False, "errors": errors}
```

### 6. 性能优化 (Performance & Optimization)

#### 模型预编译
```python
# 预编译模型以提高性能
user_model = User.__pydantic_model__

# 对于高频操作，重用已编译模型
for user_data in user_list:
    user = User(**user_data)  # 每次都编译开销大
    
# 更好的方式
UserClass = User  # 重用已编译的类
for user_data in user_list:
    user = UserClass(**user_data)  # 复用编译结果
```

#### 部分验证
```python
# 只验证特定字段
user = User(name="张三", email="zhangsan@example.com")

# 验证单个字段
try:
    User.__fields__['age'].validate(-5)  # 会抛出异常
except ValidationError as e:
    print("年龄验证失败")
```

### 7. 实际应用模式 (Practical Patterns)

#### 请求/响应模型设计
```python
# 请求模型
class CreateUserRequest(BaseModel):
    username: str = Field(..., min_length=3, max_length=50)
    email: EmailStr
    password: str = Field(..., min_length=8)

# 响应模型
class UserResponse(BaseModel):
    id: int
    username: str
    email: str
    created_at: datetime
    updated_at: datetime
    
    class Config:
        # 排除敏感字段
        fields = {
            'password': {'exclude': True}
        }

# 列表响应
class UserListResponse(BaseModel):
    items: List[UserResponse]
    total: int
    page: int
    size: int
```

#### 配置管理
```python
from pydantic import BaseSettings

class Settings(BaseSettings):
    app_name: str = "MyApp"
    database_url: str
    redis_url: str = "redis://localhost:6379"
    api_key: str
    
    # 嵌套配置
    email: EmailSettings
    
    class Config:
        env_file = ".env"
        case_sensitive = False

class EmailSettings(BaseModel):
    smtp_server: str
    smtp_port: int = 587
    username: str
    password: str

settings = Settings()
```

### 8. 版本兼容性 (Version Compatibility)

#### V1 vs V2的主要差异
```python
# Pydantic V1 (旧版)
from pydantic import BaseModel, validator

class User(BaseModel):
    name: str
    
    @validator('name')
    def validate_name(cls, v):
        return v.strip()

# Pydantic V2 (新版) - 推荐使用
from pydantic import BaseModel, field_validator

class User(BaseModel):
    name: str
    
    @field_validator('name')
    @classmethod
    def validate_name(cls, v):
        return v.strip()
```

#### 迁移策略
```python
# 兼容性导入
try:
    # V2
    from pydantic.v1 import BaseModel, validator
except ImportError:
    # V1
    from pydantic import BaseModel, validator
```

### 9. 测试策略 (Testing with Pydantic)

```python
import pytest
from pydantic import ValidationError

class TestUserModel:
    def test_valid_user_creation(self):
        user = User(name="张三", email="zhangsan@example.com")
        assert user.name == "张三"
        assert user.email == "zhangsan@example.com"
    
    def test_invalid_email(self):
        with pytest.raises(ValidationError) as exc_info:
            User(name="张三", email="invalid-email")
        
        errors = exc_info.value.errors()
        assert len(errors) == 1
        assert errors[0]['loc'] == ('email',)
        assert 'email' in errors[0]['msg']
    
    def test_field_constraints(self):
        # 测试字段长度限制
        with pytest.raises(ValidationError):
            User(name="", email="test@example.com")  # 空名称
    
    def test_serialization(self):
        user = User(name="张三", email="zhangsan@example.com")
        data = user.dict()
        assert data['name'] == "张三"
        
        json_str = user.json()
        assert '"name":"张三"' in json_str
    
    def test_custom_validator(self):
        # 测试自定义验证逻辑
        user = User(name="  张三  ", email="zhangsan@example.com")
        assert user.name == "张三"  # 应该被strip
```

### 10. 生态系统集成 (Ecosystem Integration)

## 🎯 **重点：FastAPI集成**

### 10.1 基础集成 - 自动API文档

```python
from fastapi import FastAPI, HTTPException
from pydantic import BaseModel, Field
from typing import List, Optional

app = FastAPI(
    title="用户管理系统",
    description="基于Pydantic和FastAPI的用户API",
    version="1.0.0"
)

class UserCreate(BaseModel):
    """用户创建请求模型"""
    username: str = Field(..., min_length=3, max_length=50, description="用户名")
    email: str = Field(..., description="邮箱地址")
    password: str = Field(..., min_length=8, description="密码")
    age: Optional[int] = Field(None, ge=0, le=150, description="年龄")

class UserResponse(BaseModel):
    """用户响应模型"""
    id: int
    username: str
    email: str
    age: Optional[int]
    created_at: str
    
    class Config:
        schema_extra = {
            "example": {
                "id": 1,
                "username": "zhangsan",
                "email": "zhangsan@example.com",
                "age": 25,
                "created_at": "2025-01-01T10:00:00"
            }
        }

# FastAPI自动生成API文档
@app.post("/users", response_model=UserResponse, 
          summary="创建用户", 
          description="创建一个新用户账户")
async def create_user(user: UserCreate):
    """
    创建新用户
    
    - **username**: 用户名（3-50字符）
    - **email**: 邮箱地址（必须有效）
    - **password**: 密码（至少8位）
    - **age**: 可选年龄（0-150）
    """
    # 模拟数据库操作
    new_user = {
        "id": 123,
        "username": user.username,
        "email": user.email,
        "age": user.age,
        "created_at": "2025-01-01T10:00:00"
    }
    
    return UserResponse(**new_user)
```

### 10.2 高级FastAPI集成模式

#### 查询参数验证
```python
from fastapi import Query, Path, Body

@app.get("/users", response_model=List[UserResponse])
async def list_users(
    # 自动验证查询参数
    page: int = Query(1, ge=1, le=1000, description="页码"),
    size: int = Query(20, ge=1, le=100, description="每页大小"),
    search: Optional[str] = Query(None, min_length=1, max_length=100, description="搜索关键词"),
    sort_by: str = Query("created_at", regex=r"^(username|email|created_at)$", description="排序字段"),
    sort_order: str = Query("desc", regex=r"^(asc|desc)$", description="排序方向"),
    
    # 筛选参数
    min_age: Optional[int] = Query(None, ge=0, description="最小年龄"),
    max_age: Optional[int] = Query(None, le=150, description="最大年龄")
):
    """获取用户列表，支持分页、搜索、筛选、排序"""
    # 所有参数都经过Pydantic验证
    return get_users_from_db(
        page=page, size=size, search=search,
        sort_by=sort_by, sort_order=sort_order,
        min_age=min_age, max_age=max_age
    )
```

#### 路径参数验证
```python
@app.get("/users/{user_id}", response_model=UserResponse)
async def get_user(
    user_id: int = Path(..., ge=1, description="用户ID")
):
    """获取单个用户"""
    user = get_user_from_db(user_id)
    if not user:
        raise HTTPException(404, "用户不存在")
    return user

@app.put("/users/{user_id}", response_model=UserResponse)
async def update_user(
    user_id: int = Path(..., ge=1),
    updates: UserCreate = Body(...)  # 请求体验证
):
    """更新用户信息"""
    # user_id和updates都经过验证
    return update_user_in_db(user_id, updates)
```

#### 依赖注入集成
```python
from fastapi import Depends, Request
from pydantic import BaseModel

class AuthenticatedUser(BaseModel):
    id: int
    username: str
    role: str

async def get_current_user(request: Request) -> AuthenticatedUser:
    """依赖注入：获取当前用户"""
    # 从JWT token或session中获取用户信息
    token = request.headers.get("Authorization")
    if not token:
        raise HTTPException(401, "未认证")
    
    # 验证token并返回用户信息
    user_data = decode_jwt_token(token)
    return AuthenticatedUser(**user_data)

@app.get("/profile", response_model=UserResponse)
async def get_user_profile(
    current_user: AuthenticatedUser = Depends(get_current_user)
):
    """获取当前用户资料
    
    FastAPI会自动注入current_user参数
    """
    return get_user_from_db(current_user.id)
```

#### 文件上传验证
```python
from fastapi import UploadFile, File
from pydantic import validator

class FileUploadRequest(BaseModel):
    description: str = Field(..., max_length=200)
    file: UploadFile
    
    @validator('file')
    def validate_file(cls, v):
        if not v.filename:
            raise ValueError('文件名不能为空')
        
        allowed_extensions = {'.jpg', '.jpeg', '.png', '.gif'}
        if not any(v.filename.lower().endswith(ext) for ext in allowed_extensions):
            raise ValueError('只支持图片文件')
        
        # 限制文件大小 (5MB)
        if hasattr(v, 'size') and v.size > 5 * 1024 * 1024:
            raise ValueError('文件大小不能超过5MB')
        
        return v

@app.post("/upload")
async def upload_file(request: FileUploadRequest):
    """上传文件，自动验证文件类型和大小"""
    # request.file已经经过验证
    save_uploaded_file(request.file, request.description)
    return {"message": "上传成功"}
```

#### 中间件集成
```python
from starlette.middleware.base import BaseHTTPMiddleware
from pydantic import BaseModel

class RequestLog(BaseModel):
    method: str
    path: str
    user_agent: Optional[str]
    ip: str
    timestamp: datetime = Field(default_factory=datetime.utcnow)

class LoggingMiddleware(BaseHTTPMiddleware):
    async def dispatch(self, request, call_next):
        # 使用Pydantic记录请求信息
        log_entry = RequestLog(
            method=request.method,
            path=request.url.path,
            user_agent=request.headers.get("User-Agent"),
            ip=request.client.host
        )
        
        # 可以保存到数据库或发送到日志系统
        save_request_log(log_entry)
        
        response = await call_next(request)
        return response

# 注册中间件
app.add_middleware(LoggingMiddleware)
```

#### 自定义响应类
```python
from fastapi.responses import JSONResponse
from pydantic import BaseModel

class APIResponse(BaseModel):
    success: bool
    data: Optional[dict] = None
    message: str = ""
    errors: Optional[dict] = None

class CustomJSONResponse(JSONResponse):
    def __init__(self, response_data: APIResponse, status_code: int = 200):
        super().__init__(
            content=response_data.dict(),
            status_code=status_code
        )

@app.get("/health")
async def health_check():
    response = APIResponse(
        success=True,
        data={"status": "ok", "timestamp": datetime.utcnow()},
        message="服务正常"
    )
    return CustomJSONResponse(response)
```

#### 异常处理器集成
```python
from fastapi.exceptions import RequestValidationError
from pydantic import ValidationError

class ValidationErrorResponse(BaseModel):
    success: bool = False
    error_type: str = "validation_error"
    message: str = "输入数据验证失败"
    details: list

@app.exception_handler(RequestValidationError)
async def validation_exception_handler(request, response, exc):
    """处理Pydantic验证错误"""
    
    # 转换错误格式
    errors = []
    for error in exc.errors():
        errors.append({
            "field": ".".join(str(loc) for loc in error["loc"]),
            "message": error["msg"],
            "error_type": error["type"]
        })
    
    error_response = ValidationErrorResponse(
        message="请求数据格式错误",
        details=errors
    )
    
    return CustomJSONResponse(error_response, status_code=422)

@app.exception_handler(ValidationError)
async def pydantic_validation_error_handler(request, exc):
    """处理直接的Pydantic验证错误"""
    return await validation_exception_handler(request, None, exc)
```

#### 数据库集成
```python
from sqlalchemy.ext.asyncio import AsyncSession
from fastapi import Depends

class UserDB(BaseModel):
    id: int
    username: str
    email: str
    created_at: datetime
    
    class Config:
        orm_mode = True  # 允许从SQLAlchemy模型转换

async def get_db() -> AsyncSession:
    async with AsyncSessionLocal() as session:
        try:
            yield session
        finally:
            await session.close()

@app.get("/users/{user_id}", response_model=UserDB)
async def get_user(
    user_id: int = Path(..., ge=1),
    db: AsyncSession = Depends(get_db)
):
    """获取用户，支持ORM模式"""
    user = await db.get(User, user_id)
    if not user:
        raise HTTPException(404, "用户不存在")
    
    return UserDB.from_orm(user)  # 自动从ORM模型转换
```

### 10.3 其他框架集成

#### SQLAlchemy集成
```python
from sqlalchemy import Column, Integer, String, DateTime
from sqlalchemy.ext.declarative import declarative_base

Base = declarative_base()

class UserTable(Base):
    __tablename__ = "users"
    
    id = Column(Integer, primary_key=True)
    username = Column(String(50), nullable=False)
    email = Column(String(100), unique=True)
    created_at = Column(DateTime, default=datetime.utcnow)

# Pydantic模型与SQLAlchemy集成
class UserCreate(BaseModel):
    username: str = Field(..., max_length=50)
    email: str = Field(..., max_length=100)

class UserResponse(BaseModel):
    id: int
    username: str
    email: str
    created_at: datetime
    
    class Config:
        orm_mode = True  # 启用ORM模式

# 使用
user_data = UserCreate(username="张三", email="zhangsan@example.com")
# 转换为SQLAlchemy对象
db_user = UserTable(**user_data.dict())
session.add(db_user)

# 从数据库转换回Pydantic
user_response = UserResponse.from_orm(db_user)
```

#### Redis集成
```python
import redis
from pydantic import parse_raw_as

class CacheItem(BaseModel):
    key: str
    value: str
    expires_at: Optional[datetime]

# Redis客户端
redis_client = redis.Redis(host='localhost', port=6379, decode_responses=True)

def cache_get(key: str) -> Optional[CacheItem]:
    """从Redis获取并验证数据"""
    data = redis_client.get(key)
    if data:
        try:
            return CacheItem.parse_raw(data)  # 自动验证和转换
        except ValidationError:
            redis_client.delete(key)  # 删除无效数据
    return None

def cache_set(key: str, item: CacheItem, expire_seconds: int = 3600):
    """存储到Redis"""
    redis_client.setex(key, expire_seconds, item.json())
```

