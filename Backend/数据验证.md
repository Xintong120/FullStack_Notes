### 1. åŸºç¡€æ¦‚å¿µ (Core Concepts)

#### BaseModelç±»

> é€šè¿‡ç±»å‹æ³¨è§£æ¥å®šä¹‰å­—æ®µåº”è¯¥æ˜¯ä»€ä¹ˆç±»å‹ã€‚
>
> ä½œç”¨ï¼š
>
> - **éªŒè¯æ•°æ®ç±»å‹**ï¼šç¡®ä¿ä¼ å…¥çš„æ•°æ®åŒ¹é…å®šä¹‰çš„ç±»å‹
> - **æä¾›é»˜è®¤å€¼**ï¼šå¦‚æœå­—æ®µæœ‰é»˜è®¤å€¼ï¼Œä¼šè‡ªåŠ¨å¡«å……
> - **åºåˆ—åŒ–**ï¼šå¯ä»¥å°†å¯¹è±¡è½¬æ¢ä¸ºå­—å…¸æˆ–JSON
> - **æ–‡æ¡£ç”Ÿæˆ**ï¼šè‡ªåŠ¨ç”ŸæˆAPIæ–‡æ¡£

```python
from pydantic import BaseModel
from typing import Optional 
#Optionalè¡¨ç¤º"å¯é€‰çš„"ï¼Œæ„æ€æ˜¯è¿™ä¸ªå­—æ®µå¯ä»¥æ˜¯æŒ‡å®šç±»å‹ï¼Œä¹Ÿå¯ä»¥æ˜¯`None`ã€‚

class User(BaseModel):
    # è¿™é‡Œå®šä¹‰å­—æ®µå’Œå®ƒä»¬çš„ç±»å‹
    name: str        # å­—ç¬¦ä¸²ç±»å‹ï¼Œå¿…éœ€å­—æ®µï¼šå¿…é¡»æä¾›
    age: Optional[int] = None    # å¯é€‰å­—æ®µï¼šå¯ä»¥ä¸æä¾›ï¼Œé»˜è®¤ä¸ºNone
    height: float    # æµ®ç‚¹æ•°ç±»å‹
    is_active: bool  # å¸ƒå°”ç±»å‹
    avatar: Optional[str] = None # å¯é€‰å­—æ®µï¼šå¯ä»¥ä¸æä¾›ï¼Œé»˜è®¤ä¸ºNone

# ä½¿ç”¨
user = User(id=1, name="å¼ ä¸‰", email="zhangsan@example.com")
print(user.name)  # å¼ ä¸‰
print(user.dict())  # {'id': 1, 'name': 'å¼ ä¸‰', 'email': 'zhangsan@example.com', 'age': None}
```

#### åŸºæœ¬æ•°æ®ç±»å‹
```python
from pydantic import BaseModel
from typing import List, Dict, Set 
#å®¹å™¨ç±»å‹æ³¨è§£ï¼Œç”¨æ¥æè¿°åŒ…å«å…¶ä»–æ•°æ®çš„å¤åˆç±»å‹

class Article(BaseModel):
    title: str                    # å­—ç¬¦ä¸²
    content: str                  # å­—ç¬¦ä¸²
    views: int = 0               # æ•´æ•°ï¼Œé»˜è®¤å€¼
    is_published: bool = False    # å¸ƒå°”å€¼
    tags: List[str] = []         # å­—ç¬¦ä¸²åˆ—è¡¨
    metadata: Dict[str, str] = {} # å­—å…¸
    categories: Set[str] = set()  # é›†åˆ
```



#### å®Œæ•´çš„ç±»å‹æ³¨è§£ç¤ºä¾‹

```python
from pydantic import BaseModel, Field
from typing import Optional, List, Dict, Set
from datetime import datetime

class CompleteUser(BaseModel):
    # åŸºæœ¬ç±»å‹
    id: int
    name: str
    email: str
    
    # å¯é€‰ç±»å‹
    age: Optional[int] = None
    bio: Optional[str] = None
    
    # å®¹å™¨ç±»å‹
    tags: List[str] = []
    settings: Dict[str, str] = {}
    permissions: Set[str] = set()
    
    # å¤æ‚ç±»å‹
    profile: Dict[str, Optional[str]] = {}
    created_at: datetime = Field(default_factory=datetime.utcnow)
    
    # åµŒå¥—æ¨¡å‹
    addresses: List[Dict[str, str]] = []

# ä½¿ç”¨ç¤ºä¾‹
user = CompleteUser(
    id=1,
    name="å¼ ä¸‰",
    email="zhangsan@example.com",
    age=25,
    tags=["å¼€å‘è€…", "Python"],
    settings={"theme": "dark", "notifications": "on"},
    permissions={"read", "write"},
    addresses=[
        {"type": "home", "street": "ä¸­å±±è·¯100å·"},
        {"type": "work", "street": "å—äº¬è·¯200å·"}
    ]
)

print(user.dict())
```

### å¸¸ç”¨çš„typingå¯¼å…¥

```python
from typing import (
    # åŸºæœ¬ç±»å‹
    Optional,      # å¯é€‰ç±»å‹
    Union,         # è”åˆç±»å‹
    
    # å®¹å™¨ç±»å‹
    List,          # åˆ—è¡¨
    Dict,          # å­—å…¸  
    Set,           # é›†åˆ
    Tuple,         # å…ƒç»„
    
    # æ³›å‹
    TypeVar,       # ç±»å‹å˜é‡
    Generic,       # æ³›å‹ç±»
    
    # ç‰¹æ®Šç±»å‹
    Any,           # ä»»æ„ç±»å‹
    Callable,      # å¯è°ƒç”¨ç±»å‹
    Awaitable,     # å¼‚æ­¥ç±»å‹
)
```



### 2. å­—æ®µéªŒè¯ (Field Validation)

#### çº¦æŸéªŒè¯
```python
from pydantic import BaseModel, Field, EmailStr, HttpUrl
from typing import Optional
from datetime import datetime

class Product(BaseModel):
    name: str = Field(..., min_length=1, max_length=100)
    price: float = Field(..., gt=0, le=10000)  # å¤§äº0ï¼Œå°äºç­‰äº10000
    description: Optional[str] = Field(None, max_length=500)
    email: EmailStr  # è‡ªåŠ¨éªŒè¯é‚®ç®±æ ¼å¼
    website: Optional[HttpUrl] = None  # è‡ªåŠ¨éªŒè¯URLæ ¼å¼
    created_at: datetime = Field(default_factory=datetime.utcnow)
    
    # æ­£åˆ™è¡¨è¾¾å¼éªŒè¯
    sku: str = Field(..., regex=r'^[A-Z]{2}\d{6}$')  # å¦‚ AB123456
```

#### è‡ªå®šä¹‰éªŒè¯å™¨
```python
from pydantic import BaseModel, validator, ValidationError
from typing import List

class UserCreate(BaseModel):
    username: str
    password: str
    confirm_password: str
    tags: List[str] = []
    
    @validator('username')
    def username_valid(cls, v):
        if not v.isalnum():
            raise ValueError('ç”¨æˆ·ååªèƒ½åŒ…å«å­—æ¯å’Œæ•°å­—')
        if len(v) < 3:
            raise ValueError('ç”¨æˆ·åè‡³å°‘3ä¸ªå­—ç¬¦')
        return v
    
    @validator('password')
    def password_strength(cls, v):
        if len(v) < 8:
            raise ValueError('å¯†ç è‡³å°‘8ä½')
        if not any(c.isupper() for c in v):
            raise ValueError('å¯†ç å¿…é¡»åŒ…å«å¤§å†™å­—æ¯')
        return v
    
    @validator('confirm_password')
    def passwords_match(cls, v, values):
        if 'password' in values and v != values['password']:
            raise ValueError('ä¸¤æ¬¡å¯†ç ä¸ä¸€è‡´')
        return v
    
    @validator('tags', each_item=True)
    def validate_tags(cls, v):
        if len(v) > 20:
            raise ValueError('å•ä¸ªæ ‡ç­¾ä¸èƒ½è¶…è¿‡20å­—ç¬¦')
        return v.strip()
```

### 3. æ•°æ®è½¬æ¢ (Data Conversion & Parsing)

#### JSONè§£æå’Œåºåˆ—åŒ–
```python
# è‡ªåŠ¨è§£æJSON
json_data = '{"name": "å¼ ä¸‰", "age": "25"}'  # ageæ˜¯å­—ç¬¦ä¸²
user = User(**json.loads(json_data))  # è‡ªåŠ¨è½¬æ¢ä¸ºint

# åºåˆ—åŒ–ä¸ºJSON
user_dict = user.dict()  # è½¬æ¢ä¸ºå­—å…¸
json_str = user.json()   # è½¬æ¢ä¸ºJSONå­—ç¬¦ä¸²

# æ’é™¤å­—æ®µ
user.dict(exclude={'password'})  # æ’é™¤å¯†ç å­—æ®µ
user.dict(include={'name', 'email'})  # åªåŒ…å«æŒ‡å®šå­—æ®µ
```

#### è‡ªå®šä¹‰ç±»å‹
```python
from pydantic import BaseModel
from enum import Enum

class UserRole(str, Enum):
    ADMIN = "admin"
    USER = "user"
    GUEST = "guest"

class Color:
    def __init__(self, hex_value: str):
        if not hex_value.startswith('#'):
            hex_value = f'#{hex_value}'
        self.hex_value = hex_value.upper()
    
    def __str__(self):
        return self.hex_value

class Product(BaseModel):
    name: str
    role: UserRole  # æšä¸¾ç±»å‹
    color: Color    # è‡ªå®šä¹‰ç±»å‹
    
    class Config:
        # è‡ªå®šä¹‰JSONç¼–ç å™¨
        json_encoders = {
            Color: str  # Colorå¯¹è±¡åºåˆ—åŒ–ä¸ºå­—ç¬¦ä¸²
        }

# ä½¿ç”¨
product = Product(
    name="iPhone", 
    role=UserRole.USER,
    color=Color("FF0000")
)
print(product.color)  # #FF0000
```

#### åµŒå¥—æ¨¡å‹
```python
class Address(BaseModel):
    street: str
    city: str
    country: str

class Company(BaseModel):
    name: str
    address: Address

class User(BaseModel):
    name: str
    company: Company

# åµŒå¥—æ•°æ®è‡ªåŠ¨éªŒè¯
user_data = {
    "name": "å¼ ä¸‰",
    "company": {
        "name": "ABCå…¬å¸",
        "address": {
            "street": "ä¸­å±±è·¯100å·",
            "city": "ä¸Šæµ·",
            "country": "ä¸­å›½"
        }
    }
}

user = User(**user_data)
```

### 4. é«˜çº§ç‰¹æ€§ (Advanced Features)

#### æ¨¡å‹é…ç½®
```python
class User(BaseModel):
    name: str
    email: str
    
    class Config:
        # å…è®¸ä»»æ„å­—æ®µ
        extra = 'allow'  # 'ignore', 'forbid', 'allow'
        
        # å­—æ®µåˆ«å
        allow_population_by_field_name = True
        
        # éªŒè¯å¤±è´¥æ—¶æ”¶é›†æ‰€æœ‰é”™è¯¯
        validate_all = True
        
        # è‡ªå®šä¹‰å­—æ®µåºåˆ—åŒ–å™¨
        json_encoders = {
            datetime: lambda v: v.timestamp()
        }
        
        # å­—æ®µæ’åº
        fields = {
            'name': {'title': 'å§“å'},
            'email': {'title': 'é‚®ç®±'}
        }
```

#### æ³›å‹æ”¯æŒ
```python
from typing import TypeVar, Generic
from pydantic.generics import GenericModel

DataT = TypeVar('DataT')

class Response(GenericModel, Generic[DataT]):
    success: bool
    data: DataT
    message: str = ""

# ä½¿ç”¨æ³›å‹
user_response = Response[User](success=True, data=user, message="è·å–æˆåŠŸ")
product_response = Response[Product](success=True, data=product)
```

#### ç»§æ‰¿å’Œç»„åˆ
```python
class BaseEntity(BaseModel):
    id: int
    created_at: datetime = Field(default_factory=datetime.utcnow)
    updated_at: datetime = Field(default_factory=datetime.utcnow)

class User(BaseEntity):
    name: str
    email: str

class Article(BaseEntity):
    title: str
    content: str
    author_id: int

# ç»§æ‰¿è‡ªåŠ¨åŒ…å«çˆ¶ç±»å­—æ®µ
user = User(id=1, name="å¼ ä¸‰", email="zhangsan@example.com")
article = Article(id=1, title="æ ‡é¢˜", content="å†…å®¹", author_id=1)
```

### 5. é”™è¯¯å¤„ç† (Error Handling)

#### ValidationErrorå¼‚å¸¸
```python
from pydantic import ValidationError

try:
    user = User(name="", email="invalid-email", age=-5)
except ValidationError as e:
    # è¯¦ç»†çš„é”™è¯¯ä¿¡æ¯
    print(e.errors())
    """
    [
        {
            'loc': ('name',),
            'msg': 'ensure this value has at least 1 characters',
            'type': 'value_error.any_str.min_length',
            'ctx': {'limit_value': 1}
        },
        {
            'loc': ('email',),
            'msg': 'value is not a valid email address',
            'type': 'value_error.email'
        },
        {
            'loc': ('age',),
            'msg': 'ensure this value is greater than or equal to 0',
            'type': 'value_error.const',
            'ctx': {'limit_value': 0}
        }
    ]
    """
```

#### è‡ªå®šä¹‰é”™è¯¯å¤„ç†
```python
def handle_validation_error(e: ValidationError) -> dict:
    """è½¬æ¢Pydanticé”™è¯¯ä¸ºç”¨æˆ·å‹å¥½çš„æ ¼å¼"""
    errors = {}
    for error in e.errors():
        field = '.'.join(str(loc) for loc in error['loc'])
        
        # è‡ªå®šä¹‰é”™è¯¯æ¶ˆæ¯
        if error['type'] == 'value_error.email':
            message = "é‚®ç®±æ ¼å¼ä¸æ­£ç¡®"
        elif 'min_length' in error['type']:
            message = f"æœ€å°‘éœ€è¦{error['ctx']['limit_value']}ä¸ªå­—ç¬¦"
        else:
            message = error['msg']
        
        errors[field] = message
    
    return {"success": False, "errors": errors}
```

### 6. æ€§èƒ½ä¼˜åŒ– (Performance & Optimization)

#### æ¨¡å‹é¢„ç¼–è¯‘
```python
# é¢„ç¼–è¯‘æ¨¡å‹ä»¥æé«˜æ€§èƒ½
user_model = User.__pydantic_model__

# å¯¹äºé«˜é¢‘æ“ä½œï¼Œé‡ç”¨å·²ç¼–è¯‘æ¨¡å‹
for user_data in user_list:
    user = User(**user_data)  # æ¯æ¬¡éƒ½ç¼–è¯‘å¼€é”€å¤§
    
# æ›´å¥½çš„æ–¹å¼
UserClass = User  # é‡ç”¨å·²ç¼–è¯‘çš„ç±»
for user_data in user_list:
    user = UserClass(**user_data)  # å¤ç”¨ç¼–è¯‘ç»“æœ
```

#### éƒ¨åˆ†éªŒè¯
```python
# åªéªŒè¯ç‰¹å®šå­—æ®µ
user = User(name="å¼ ä¸‰", email="zhangsan@example.com")

# éªŒè¯å•ä¸ªå­—æ®µ
try:
    User.__fields__['age'].validate(-5)  # ä¼šæŠ›å‡ºå¼‚å¸¸
except ValidationError as e:
    print("å¹´é¾„éªŒè¯å¤±è´¥")
```

### 7. å®é™…åº”ç”¨æ¨¡å¼ (Practical Patterns)

#### è¯·æ±‚/å“åº”æ¨¡å‹è®¾è®¡
```python
# è¯·æ±‚æ¨¡å‹
class CreateUserRequest(BaseModel):
    username: str = Field(..., min_length=3, max_length=50)
    email: EmailStr
    password: str = Field(..., min_length=8)

# å“åº”æ¨¡å‹
class UserResponse(BaseModel):
    id: int
    username: str
    email: str
    created_at: datetime
    updated_at: datetime
    
    class Config:
        # æ’é™¤æ•æ„Ÿå­—æ®µ
        fields = {
            'password': {'exclude': True}
        }

# åˆ—è¡¨å“åº”
class UserListResponse(BaseModel):
    items: List[UserResponse]
    total: int
    page: int
    size: int
```

#### é…ç½®ç®¡ç†
```python
from pydantic import BaseSettings

class Settings(BaseSettings):
    app_name: str = "MyApp"
    database_url: str
    redis_url: str = "redis://localhost:6379"
    api_key: str
    
    # åµŒå¥—é…ç½®
    email: EmailSettings
    
    class Config:
        env_file = ".env"
        case_sensitive = False

class EmailSettings(BaseModel):
    smtp_server: str
    smtp_port: int = 587
    username: str
    password: str

settings = Settings()
```

### 8. ç‰ˆæœ¬å…¼å®¹æ€§ (Version Compatibility)

#### V1 vs V2çš„ä¸»è¦å·®å¼‚
```python
# Pydantic V1 (æ—§ç‰ˆ)
from pydantic import BaseModel, validator

class User(BaseModel):
    name: str
    
    @validator('name')
    def validate_name(cls, v):
        return v.strip()

# Pydantic V2 (æ–°ç‰ˆ) - æ¨èä½¿ç”¨
from pydantic import BaseModel, field_validator

class User(BaseModel):
    name: str
    
    @field_validator('name')
    @classmethod
    def validate_name(cls, v):
        return v.strip()
```

#### è¿ç§»ç­–ç•¥
```python
# å…¼å®¹æ€§å¯¼å…¥
try:
    # V2
    from pydantic.v1 import BaseModel, validator
except ImportError:
    # V1
    from pydantic import BaseModel, validator
```

### 9. æµ‹è¯•ç­–ç•¥ (Testing with Pydantic)

```python
import pytest
from pydantic import ValidationError

class TestUserModel:
    def test_valid_user_creation(self):
        user = User(name="å¼ ä¸‰", email="zhangsan@example.com")
        assert user.name == "å¼ ä¸‰"
        assert user.email == "zhangsan@example.com"
    
    def test_invalid_email(self):
        with pytest.raises(ValidationError) as exc_info:
            User(name="å¼ ä¸‰", email="invalid-email")
        
        errors = exc_info.value.errors()
        assert len(errors) == 1
        assert errors[0]['loc'] == ('email',)
        assert 'email' in errors[0]['msg']
    
    def test_field_constraints(self):
        # æµ‹è¯•å­—æ®µé•¿åº¦é™åˆ¶
        with pytest.raises(ValidationError):
            User(name="", email="test@example.com")  # ç©ºåç§°
    
    def test_serialization(self):
        user = User(name="å¼ ä¸‰", email="zhangsan@example.com")
        data = user.dict()
        assert data['name'] == "å¼ ä¸‰"
        
        json_str = user.json()
        assert '"name":"å¼ ä¸‰"' in json_str
    
    def test_custom_validator(self):
        # æµ‹è¯•è‡ªå®šä¹‰éªŒè¯é€»è¾‘
        user = User(name="  å¼ ä¸‰  ", email="zhangsan@example.com")
        assert user.name == "å¼ ä¸‰"  # åº”è¯¥è¢«strip
```

### 10. ç”Ÿæ€ç³»ç»Ÿé›†æˆ (Ecosystem Integration)

## ğŸ¯ **é‡ç‚¹ï¼šFastAPIé›†æˆ**

### 10.1 åŸºç¡€é›†æˆ - è‡ªåŠ¨APIæ–‡æ¡£

```python
from fastapi import FastAPI, HTTPException
from pydantic import BaseModel, Field
from typing import List, Optional

app = FastAPI(
    title="ç”¨æˆ·ç®¡ç†ç³»ç»Ÿ",
    description="åŸºäºPydanticå’ŒFastAPIçš„ç”¨æˆ·API",
    version="1.0.0"
)

class UserCreate(BaseModel):
    """ç”¨æˆ·åˆ›å»ºè¯·æ±‚æ¨¡å‹"""
    username: str = Field(..., min_length=3, max_length=50, description="ç”¨æˆ·å")
    email: str = Field(..., description="é‚®ç®±åœ°å€")
    password: str = Field(..., min_length=8, description="å¯†ç ")
    age: Optional[int] = Field(None, ge=0, le=150, description="å¹´é¾„")

class UserResponse(BaseModel):
    """ç”¨æˆ·å“åº”æ¨¡å‹"""
    id: int
    username: str
    email: str
    age: Optional[int]
    created_at: str
    
    class Config:
        schema_extra = {
            "example": {
                "id": 1,
                "username": "zhangsan",
                "email": "zhangsan@example.com",
                "age": 25,
                "created_at": "2025-01-01T10:00:00"
            }
        }

# FastAPIè‡ªåŠ¨ç”ŸæˆAPIæ–‡æ¡£
@app.post("/users", response_model=UserResponse, 
          summary="åˆ›å»ºç”¨æˆ·", 
          description="åˆ›å»ºä¸€ä¸ªæ–°ç”¨æˆ·è´¦æˆ·")
async def create_user(user: UserCreate):
    """
    åˆ›å»ºæ–°ç”¨æˆ·
    
    - **username**: ç”¨æˆ·åï¼ˆ3-50å­—ç¬¦ï¼‰
    - **email**: é‚®ç®±åœ°å€ï¼ˆå¿…é¡»æœ‰æ•ˆï¼‰
    - **password**: å¯†ç ï¼ˆè‡³å°‘8ä½ï¼‰
    - **age**: å¯é€‰å¹´é¾„ï¼ˆ0-150ï¼‰
    """
    # æ¨¡æ‹Ÿæ•°æ®åº“æ“ä½œ
    new_user = {
        "id": 123,
        "username": user.username,
        "email": user.email,
        "age": user.age,
        "created_at": "2025-01-01T10:00:00"
    }
    
    return UserResponse(**new_user)
```

### 10.2 é«˜çº§FastAPIé›†æˆæ¨¡å¼

#### æŸ¥è¯¢å‚æ•°éªŒè¯
```python
from fastapi import Query, Path, Body

@app.get("/users", response_model=List[UserResponse])
async def list_users(
    # è‡ªåŠ¨éªŒè¯æŸ¥è¯¢å‚æ•°
    page: int = Query(1, ge=1, le=1000, description="é¡µç "),
    size: int = Query(20, ge=1, le=100, description="æ¯é¡µå¤§å°"),
    search: Optional[str] = Query(None, min_length=1, max_length=100, description="æœç´¢å…³é”®è¯"),
    sort_by: str = Query("created_at", regex=r"^(username|email|created_at)$", description="æ’åºå­—æ®µ"),
    sort_order: str = Query("desc", regex=r"^(asc|desc)$", description="æ’åºæ–¹å‘"),
    
    # ç­›é€‰å‚æ•°
    min_age: Optional[int] = Query(None, ge=0, description="æœ€å°å¹´é¾„"),
    max_age: Optional[int] = Query(None, le=150, description="æœ€å¤§å¹´é¾„")
):
    """è·å–ç”¨æˆ·åˆ—è¡¨ï¼Œæ”¯æŒåˆ†é¡µã€æœç´¢ã€ç­›é€‰ã€æ’åº"""
    # æ‰€æœ‰å‚æ•°éƒ½ç»è¿‡PydanticéªŒè¯
    return get_users_from_db(
        page=page, size=size, search=search,
        sort_by=sort_by, sort_order=sort_order,
        min_age=min_age, max_age=max_age
    )
```

#### è·¯å¾„å‚æ•°éªŒè¯
```python
@app.get("/users/{user_id}", response_model=UserResponse)
async def get_user(
    user_id: int = Path(..., ge=1, description="ç”¨æˆ·ID")
):
    """è·å–å•ä¸ªç”¨æˆ·"""
    user = get_user_from_db(user_id)
    if not user:
        raise HTTPException(404, "ç”¨æˆ·ä¸å­˜åœ¨")
    return user

@app.put("/users/{user_id}", response_model=UserResponse)
async def update_user(
    user_id: int = Path(..., ge=1),
    updates: UserCreate = Body(...)  # è¯·æ±‚ä½“éªŒè¯
):
    """æ›´æ–°ç”¨æˆ·ä¿¡æ¯"""
    # user_idå’Œupdateséƒ½ç»è¿‡éªŒè¯
    return update_user_in_db(user_id, updates)
```

#### ä¾èµ–æ³¨å…¥é›†æˆ
```python
from fastapi import Depends, Request
from pydantic import BaseModel

class AuthenticatedUser(BaseModel):
    id: int
    username: str
    role: str

async def get_current_user(request: Request) -> AuthenticatedUser:
    """ä¾èµ–æ³¨å…¥ï¼šè·å–å½“å‰ç”¨æˆ·"""
    # ä»JWT tokenæˆ–sessionä¸­è·å–ç”¨æˆ·ä¿¡æ¯
    token = request.headers.get("Authorization")
    if not token:
        raise HTTPException(401, "æœªè®¤è¯")
    
    # éªŒè¯tokenå¹¶è¿”å›ç”¨æˆ·ä¿¡æ¯
    user_data = decode_jwt_token(token)
    return AuthenticatedUser(**user_data)

@app.get("/profile", response_model=UserResponse)
async def get_user_profile(
    current_user: AuthenticatedUser = Depends(get_current_user)
):
    """è·å–å½“å‰ç”¨æˆ·èµ„æ–™
    
    FastAPIä¼šè‡ªåŠ¨æ³¨å…¥current_userå‚æ•°
    """
    return get_user_from_db(current_user.id)
```

#### æ–‡ä»¶ä¸Šä¼ éªŒè¯
```python
from fastapi import UploadFile, File
from pydantic import validator

class FileUploadRequest(BaseModel):
    description: str = Field(..., max_length=200)
    file: UploadFile
    
    @validator('file')
    def validate_file(cls, v):
        if not v.filename:
            raise ValueError('æ–‡ä»¶åä¸èƒ½ä¸ºç©º')
        
        allowed_extensions = {'.jpg', '.jpeg', '.png', '.gif'}
        if not any(v.filename.lower().endswith(ext) for ext in allowed_extensions):
            raise ValueError('åªæ”¯æŒå›¾ç‰‡æ–‡ä»¶')
        
        # é™åˆ¶æ–‡ä»¶å¤§å° (5MB)
        if hasattr(v, 'size') and v.size > 5 * 1024 * 1024:
            raise ValueError('æ–‡ä»¶å¤§å°ä¸èƒ½è¶…è¿‡5MB')
        
        return v

@app.post("/upload")
async def upload_file(request: FileUploadRequest):
    """ä¸Šä¼ æ–‡ä»¶ï¼Œè‡ªåŠ¨éªŒè¯æ–‡ä»¶ç±»å‹å’Œå¤§å°"""
    # request.fileå·²ç»ç»è¿‡éªŒè¯
    save_uploaded_file(request.file, request.description)
    return {"message": "ä¸Šä¼ æˆåŠŸ"}
```

#### ä¸­é—´ä»¶é›†æˆ
```python
from starlette.middleware.base import BaseHTTPMiddleware
from pydantic import BaseModel

class RequestLog(BaseModel):
    method: str
    path: str
    user_agent: Optional[str]
    ip: str
    timestamp: datetime = Field(default_factory=datetime.utcnow)

class LoggingMiddleware(BaseHTTPMiddleware):
    async def dispatch(self, request, call_next):
        # ä½¿ç”¨Pydanticè®°å½•è¯·æ±‚ä¿¡æ¯
        log_entry = RequestLog(
            method=request.method,
            path=request.url.path,
            user_agent=request.headers.get("User-Agent"),
            ip=request.client.host
        )
        
        # å¯ä»¥ä¿å­˜åˆ°æ•°æ®åº“æˆ–å‘é€åˆ°æ—¥å¿—ç³»ç»Ÿ
        save_request_log(log_entry)
        
        response = await call_next(request)
        return response

# æ³¨å†Œä¸­é—´ä»¶
app.add_middleware(LoggingMiddleware)
```

#### è‡ªå®šä¹‰å“åº”ç±»
```python
from fastapi.responses import JSONResponse
from pydantic import BaseModel

class APIResponse(BaseModel):
    success: bool
    data: Optional[dict] = None
    message: str = ""
    errors: Optional[dict] = None

class CustomJSONResponse(JSONResponse):
    def __init__(self, response_data: APIResponse, status_code: int = 200):
        super().__init__(
            content=response_data.dict(),
            status_code=status_code
        )

@app.get("/health")
async def health_check():
    response = APIResponse(
        success=True,
        data={"status": "ok", "timestamp": datetime.utcnow()},
        message="æœåŠ¡æ­£å¸¸"
    )
    return CustomJSONResponse(response)
```

#### å¼‚å¸¸å¤„ç†å™¨é›†æˆ
```python
from fastapi.exceptions import RequestValidationError
from pydantic import ValidationError

class ValidationErrorResponse(BaseModel):
    success: bool = False
    error_type: str = "validation_error"
    message: str = "è¾“å…¥æ•°æ®éªŒè¯å¤±è´¥"
    details: list

@app.exception_handler(RequestValidationError)
async def validation_exception_handler(request, response, exc):
    """å¤„ç†PydanticéªŒè¯é”™è¯¯"""
    
    # è½¬æ¢é”™è¯¯æ ¼å¼
    errors = []
    for error in exc.errors():
        errors.append({
            "field": ".".join(str(loc) for loc in error["loc"]),
            "message": error["msg"],
            "error_type": error["type"]
        })
    
    error_response = ValidationErrorResponse(
        message="è¯·æ±‚æ•°æ®æ ¼å¼é”™è¯¯",
        details=errors
    )
    
    return CustomJSONResponse(error_response, status_code=422)

@app.exception_handler(ValidationError)
async def pydantic_validation_error_handler(request, exc):
    """å¤„ç†ç›´æ¥çš„PydanticéªŒè¯é”™è¯¯"""
    return await validation_exception_handler(request, None, exc)
```

#### æ•°æ®åº“é›†æˆ
```python
from sqlalchemy.ext.asyncio import AsyncSession
from fastapi import Depends

class UserDB(BaseModel):
    id: int
    username: str
    email: str
    created_at: datetime
    
    class Config:
        orm_mode = True  # å…è®¸ä»SQLAlchemyæ¨¡å‹è½¬æ¢

async def get_db() -> AsyncSession:
    async with AsyncSessionLocal() as session:
        try:
            yield session
        finally:
            await session.close()

@app.get("/users/{user_id}", response_model=UserDB)
async def get_user(
    user_id: int = Path(..., ge=1),
    db: AsyncSession = Depends(get_db)
):
    """è·å–ç”¨æˆ·ï¼Œæ”¯æŒORMæ¨¡å¼"""
    user = await db.get(User, user_id)
    if not user:
        raise HTTPException(404, "ç”¨æˆ·ä¸å­˜åœ¨")
    
    return UserDB.from_orm(user)  # è‡ªåŠ¨ä»ORMæ¨¡å‹è½¬æ¢
```

### 10.3 å…¶ä»–æ¡†æ¶é›†æˆ

#### SQLAlchemyé›†æˆ
```python
from sqlalchemy import Column, Integer, String, DateTime
from sqlalchemy.ext.declarative import declarative_base

Base = declarative_base()

class UserTable(Base):
    __tablename__ = "users"
    
    id = Column(Integer, primary_key=True)
    username = Column(String(50), nullable=False)
    email = Column(String(100), unique=True)
    created_at = Column(DateTime, default=datetime.utcnow)

# Pydanticæ¨¡å‹ä¸SQLAlchemyé›†æˆ
class UserCreate(BaseModel):
    username: str = Field(..., max_length=50)
    email: str = Field(..., max_length=100)

class UserResponse(BaseModel):
    id: int
    username: str
    email: str
    created_at: datetime
    
    class Config:
        orm_mode = True  # å¯ç”¨ORMæ¨¡å¼

# ä½¿ç”¨
user_data = UserCreate(username="å¼ ä¸‰", email="zhangsan@example.com")
# è½¬æ¢ä¸ºSQLAlchemyå¯¹è±¡
db_user = UserTable(**user_data.dict())
session.add(db_user)

# ä»æ•°æ®åº“è½¬æ¢å›Pydantic
user_response = UserResponse.from_orm(db_user)
```

#### Redisé›†æˆ
```python
import redis
from pydantic import parse_raw_as

class CacheItem(BaseModel):
    key: str
    value: str
    expires_at: Optional[datetime]

# Rediså®¢æˆ·ç«¯
redis_client = redis.Redis(host='localhost', port=6379, decode_responses=True)

def cache_get(key: str) -> Optional[CacheItem]:
    """ä»Redisè·å–å¹¶éªŒè¯æ•°æ®"""
    data = redis_client.get(key)
    if data:
        try:
            return CacheItem.parse_raw(data)  # è‡ªåŠ¨éªŒè¯å’Œè½¬æ¢
        except ValidationError:
            redis_client.delete(key)  # åˆ é™¤æ— æ•ˆæ•°æ®
    return None

def cache_set(key: str, item: CacheItem, expire_seconds: int = 3600):
    """å­˜å‚¨åˆ°Redis"""
    redis_client.setex(key, expire_seconds, item.json())
```

