## 1. 数据库是什么？

### 通俗解释：
**数据库** = **电子文件柜**，专门用来存储和管理数据的"仓库"。

### 专业定义：
数据库是按照数据结构来组织、存储和管理数据的仓库。它能为各种用户共享，具有尽可能小的冗余度，与应用程序彼此独立。

### 日常生活中的数据库：
- **电话簿**：存储姓名和电话号码
- **学生管理系统**：存储学生信息、成绩、课程
- **银行系统**：存储账户信息、交易记录
- **电商网站**：存储商品、订单、用户信息

## 2. 数据库的组成部分

### 数据存储结构：
```
数据库 (Database)
├── 表 (Table) - 如 users, orders, products
│   ├── 行 (Row) - 每条记录
│   └── 列 (Column) - 每个字段
│       ├── 主键 (Primary Key) - 唯一标识
│       ├── 外键 (Foreign Key) - 关联其他表
│       └── 索引 (Index) - 加速查询
└── 关系 (Relationships) - 表之间的关联
```

### 例如：电商数据库结构
```
users表：
id | name | email | created_at
1  | 张三 | zhang@example.com | 2025-01-01

products表：
id | name | price | category_id
1  | iPhone | 5999 | 3

orders表：
id | user_id | product_id | quantity | created_at
1  | 1       | 1          | 1        | 2025-01-01
```

## 3. 数据库类型

### 3.1 关系型数据库 (RDBMS - Relational Database Management System)

#### 特点：
- **表格结构**：数据存储在有行和列的表中
- **SQL查询**：使用结构化查询语言
- **ACID特性**：原子性、一致性、隔离性、耐久性
- **强一致性**：数据始终保持一致

#### 代表产品：
```python
# 你的项目使用了 SQLite
import sqlite3

# 连接数据库
conn = sqlite3.connect('example.db')

# 创建表
conn.execute('''
    CREATE TABLE users (
        id INTEGER PRIMARY KEY,
        name TEXT NOT NULL,
        email TEXT UNIQUE,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    )
''')

# 插入数据
conn.execute("INSERT INTO users (name, email) VALUES (?, ?)", 
            ("张三", "zhang@example.com"))

# 查询数据
cursor = conn.execute("SELECT * FROM users WHERE name = ?", ("张三",))
users = cursor.fetchall()

conn.commit()
conn.close()
```

**优点**：
- 数据一致性强
- 支持复杂查询
- 支持事务
- 成熟稳定

**缺点**：
- 扩展性相对较差
- 对大数据量处理效率较低

### 3.2 非关系型数据库 (NoSQL)

#### 文档型 (MongoDB)
```python
# 存储JSON-like文档
{
  "_id": ObjectId("507f1f77bcf86cd799439011"),
  "name": "张三",
  "email": "zhang@example.com",
  "orders": [
    {
      "product": "iPhone",
      "price": 5999,
      "date": "2025-01-01"
    }
  ]
}
```

#### 键值型 (Redis)
```python
# 简单的键值存储
SET user:1:name "张三"
SET user:1:email "zhang@example.com"
GET user:1:name  # 返回 "张三"
```

## 4. 如何选择数据库？

### 4.1 项目规模选择

#### 小型项目/原型开发：
```
SQLite 或 JSON文件
```
- **SQLite**：文件数据库，无需服务器，适合单机应用
- **JSON文件**：简单快速，但查询功能弱

#### 中型项目：
```
PostgreSQL 或 MySQL
```
- **PostgreSQL**：功能强大，开源免费
- **MySQL**：成熟稳定，企业应用多

#### 大型项目：
```
分布式数据库
```
- **Cassandra**：高可用，适合大规模数据
- **MongoDB**：灵活，适合快速变化的数据结构

### 4.2 应用场景选择

#### 博客/CMS系统：
```python
# 需要存储文章、用户、评论等结构化数据
# 选择：PostgreSQL
articles = Table('articles', metadata,
    Column('id', Integer, primary_key=True),
    Column('title', String(200), nullable=False),
    Column('content', Text),
    Column('author_id', Integer, ForeignKey('users.id')),
    Column('created_at', DateTime, default=datetime.utcnow)
)
```

#### 实时聊天应用：
```python
# 需要快速读写消息，支持WebSocket
# 选择：PostgreSQL + Redis
# PostgreSQL存消息历史，Redis做缓存和实时推送
```

#### 电商平台：
```python
# 需要事务支持，复杂查询
# 选择：PostgreSQL 或 MySQL
```

#### 
### 4.3 技术栈选择因素

#### Python后端数据库选择：

| 数据库     | Python集成 | 复杂度 | 适用场景           |
| ---------- | ---------- | ------ | ------------------ |
| SQLite     | 内置       | ⭐⭐     | 开发/测试/小型应用 |
| PostgreSQL | SQLAlchemy | ⭐⭐⭐⭐   | 生产环境/复杂应用  |
| MySQL      | SQLAlchemy | ⭐⭐⭐⭐   | 企业应用           |
| MongoDB    | PyMongo    | ⭐⭐⭐    | JSON数据/快速开发  |
| Redis      | redis-py   | ⭐⭐     | 缓存/会话/计数     |

## 5. 数据库设计原则

### 5.1 规范化 (Normalization)
避免数据冗余，确保数据一致性：

**未规范化（坏的）：**
```
users表：
id | name | email | address_street | address_city | address_country
1  | 张三 | zhang@example.com | 中山路100号 | 上海 | 中国
```

**规范化（好的）：**
```
users表：
id | name | email | address_id
1  | 张三 | zhang@example.com | 1

addresses表：
id | street | city | country
1  | 中山路100号 | 上海 | 中国
```

### 5.2 索引设计
```sql
-- 为常用查询字段创建索引
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_products_category_price ON products(category_id, price);

-- 复合索引：category + price一起查询时更快
```

### 5.3 数据类型选择
```python
# SQLAlchemy中的数据类型
from sqlalchemy import Column, Integer, String, Text, DateTime, DECIMAL, Boolean

class Product(Base):
    __tablename__ = 'products'
    
    id = Column(Integer, primary_key=True)
    name = Column(String(200), nullable=False)  # 变长字符串
    description = Column(Text)                  # 长文本
    price = Column(DECIMAL(10, 2))             # 精确小数
    is_active = Column(Boolean, default=True)   # 布尔值
    created_at = Column(DateTime, default=datetime.utcnow)
```

## 6. 在项目中使用数据库

### 6.1 连接配置
```python
# config.py
class Settings(BaseSettings):
    # SQLite（开发）
    database_url: str = "sqlite:///./app.db"
    
    # PostgreSQL（生产）
    # database_url: str = "postgresql://user:password@localhost/dbname"
```

### 6.2 ORM使用 (SQLAlchemy)
```python
from sqlalchemy import create_engine, Column, Integer, String
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker

# 创建引擎
engine = create_engine(settings.database_url)

# 创建会话
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

# 定义模型
Base = declarative_base()

class User(Base):
    __tablename__ = "users"
    
    id = Column(Integer, primary_key=True, index=True)
    name = Column(String, index=True)
    email = Column(String, unique=True, index=True)

# 创建表
Base.metadata.create_all(bind=engine)

# 使用数据库
def get_user_by_id(user_id: int):
    db = SessionLocal()
    try:
        user = db.query(User).filter(User.id == user_id).first()
        return user
    finally:
        db.close()
```

### 6.3 FastAPI中的数据库依赖
```python
from fastapi import Depends
from sqlalchemy.orm import Session

def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

@app.get("/users/{user_id}")
def get_user(user_id: int, db: Session = Depends(get_db)):
    user = db.query(User).filter(User.id == user_id).first()
    return user
```

数据库是后端开发的基础，选择合适的数据库并正确设计数据结构对整个应用至关重要。从简单开始，SQLite很适合学习和小型项目！