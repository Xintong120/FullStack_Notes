## **数据验证（优先）**

### 1.`pydantic` - 数据验证和建模

**什么是 pydantic？**

- Python **数据验证和建模**库
- 使用 Python **类型注解**进行验证
- **自动类型转换**和**验证**
- 需要安装：`pip install pydantic`

**为什么用 pydantic？**

```python
from pydantic import BaseModel, Field

# 传统方式（手动验证）
def create_user(data: dict):
    if not isinstance(data.get("name"), str):
        raise ValueError("name must be string")
    if not isinstance(data.get("age"), int):
        raise ValueError("age must be int")
    if data["age"] < 0:
        raise ValueError("age must be positive")
    # ... 更多验证

# pydantic 方式（自动验证）
class User(BaseModel):
    name: str
    age: int = Field(gt=0)  # 自动验证 > 0
    email: str | None = None

# 使用
user = User(name="Alice", age=30)
# user = User(name="Bob", age=-5)  # ❌ ValidationError
# user = User(name="Bob", age="30")  # ✅ 自动转换为 int

# 优势：
# 1. 自动类型验证和转换
# 2. 清晰的数据结构定义
# 3. 自动生成 JSON Schema
# 4. IDE 类型提示
```

---

#### **核心概念速查表**

| 概念                  | 作用             | 示例                              |
| --------------------- | ---------------- | --------------------------------- |
| `BaseModel`           | 基础模型类       | `class User(BaseModel)`           |
| `Field()`             | 字段配置         | `Field(gt=0, description="年龄")` |
| `model_validate()`    | 验证数据         | `User.model_validate(data)`       |
| `model_dump()`        | 转为字典         | `user.model_dump()`               |
| `model_json_schema()` | 生成 JSON Schema | `User.model_json_schema()`        |
| `@field_validator`    | 自定义验证器     | 验证逻辑                          |
| `ConfigDict`          | 模型配置         | 行为配置                          |

---

> ## **AutoGPT Platform 中的实际使用**
>
> #### **案例 1：BlockSchema - Block 的核心**
>
> ```python
> # backend/data/block.py
> from pydantic import BaseModel, Field
> 
> class BlockSchema(BaseModel):
>     """Block 的输入/输出 Schema 基类"""
>     
>     model_config = ConfigDict(
>         # 允许额外字段（用于扩展）
>         extra="allow",
>         # 允许任意类型
>         arbitrary_types_allowed=True,
>     )
>     
>     @classmethod
>     def jsonschema(cls) -> dict[str, Any]:
>         """生成 JSON Schema"""
>         model = cls.model_json_schema()
>         return cast(dict[str, Any], model)
>     
>     @classmethod
>     def get_required_fields(cls) -> set[str]:
>         """获取必填字段"""
>         return {
>             field
>             for field, field_info in cls.model_fields.items()
>             if field_info.is_required()
>         }
> 
> # 使用示例
> class FileStoreBlock(Block):
>     class Input(BlockSchema):
>         file_in: MediaFileType = SchemaField(
>             description="The file to store"
>         )
>         base_64: bool = SchemaField(
>             description="Base64 output",
>             default=False,  # 有默认值，非必填
>             advanced=True,
>         )
>     
>     class Output(BlockSchema):
>         file_out: MediaFileType = SchemaField(
>             description="Stored file path"
>         )
> ```
>
> ---
>
> #### **案例 2：User 模型 - 完整配置**
>
> ```python
> # backend/data/model.py
> from pydantic import BaseModel, Field, ConfigDict
> 
> class User(BaseModel):
>     """用户模型"""
>     
>     model_config = ConfigDict(
>         extra="forbid",  # 禁止额外字段
>         str_strip_whitespace=True,  # 自动去除空白
>     )
>     
>     id: str = Field(..., description="User ID")
>     #         ^^^^ ... 表示必填
>     email: str = Field(..., description="User email")
>     name: Optional[str] = Field(None, description="Display name")
>     #                          ^^^^ None 表示可选
>     created_at: datetime = Field(..., description="Created time")
>     
>     # 默认值
>     email_verified: bool = Field(default=True)
>     max_emails_per_day: int = Field(default=3)
>     
>     # 嵌套模型
>     top_up_config: Optional["AutoTopUpConfig"] = Field(None)
>     
>     @classmethod
>     def from_db(cls, prisma_user) -> "User":
>         """从数据库对象创建"""
>         return cls.model_validate(prisma_user.model_dump())
> ```
>
> ---
>
> #### **案例 3：通知模型 - 验证器和计算字段**
>
> ```python
> # backend/data/notifications.py
> from pydantic import BaseModel, Field, field_validator, computed_field
> 
> class BaseNotificationData(BaseModel):
>     model_config = ConfigDict(extra="allow")  # 允许额外字段
> 
> class NotificationPreference(BaseModel):
>     user_id: str
>     email: EmailStr  # 自动验证邮箱格式
>     preferences: dict[NotificationType, bool]
>     daily_limit: int = Field(ge=0, le=100)  # 0-100 之间
>     
>     @field_validator('daily_limit')
>     @classmethod
>     def validate_limit(cls, v):
>         """自定义验证"""
>         if v < 0:
>             raise ValueError("daily_limit must be >= 0")
>         return v
>     
>     @computed_field
>     @property
>     def is_active(self) -> bool:
>         """计算字段"""
>         return any(self.preferences.values())
> ```
>

#### **核心概念详解**

**1. BaseModel 基础**

```python
from pydantic import BaseModel

class User(BaseModel):
    name: str
    age: int
    email: str | None = None  # 可选字段

# 创建实例
user = User(name="Alice", age=30)
print(user.name)  # "Alice"
print(user.age)   # 30

# 自动类型转换
user2 = User(name="Bob", age="25")  # age 是字符串
print(user2.age)  # 25 (自动转换为 int)

# 转换为字典
print(user.model_dump())
# {'name': 'Alice', 'age': 30, 'email': None}

# 转换为 JSON
print(user.model_dump_json())
# '{"name":"Alice","age":30,"email":null}'

# 从字典创建
data = {"name": "Charlie", "age": 35}
user3 = User.model_validate(data)
```

---

**2. Field() - 字段配置**

```python
from pydantic import BaseModel, Field

class Product(BaseModel):
    # 基础配置
    name: str = Field(description="Product name")
    price: float = Field(gt=0, description="Price must be > 0")
    #                    ^^^^ 大于 0
    
    # 数值限制
    stock: int = Field(ge=0, le=1000)
    #                  ^^^^ 大于等于 0, 小于等于 1000
    discount: float = Field(ge=0.0, le=1.0)  # 0-1 之间
    
    # 字符串限制
    sku: str = Field(min_length=5, max_length=20)
    description: str = Field(default="", max_length=500)
    
    # 默认值
    available: bool = Field(default=True)
    tags: list[str] = Field(default_factory=list)
    #                       ^^^^^^^^^^^^^ 可变默认值用工厂函数
    
    # 别名
    product_id: str = Field(alias="id")
    
    # 示例值（文档用）
    rating: float = Field(examples=[4.5, 3.8])

# 使用
product = Product(
    name="Laptop",
    price=999.99,
    stock=50,
    discount=0.1,
    sku="LAP12345"
)
```

**常用 Field 参数：**
```python
Field(
    default=...,          # 默认值（... 表示必填）
    default_factory=...,  # 默认值工厂函数
    alias=...,           # 字段别名
    description=...,     # 字段描述
    examples=[...],      # 示例值
    
    # 数值限制
    gt=...,             # 大于
    ge=...,             # 大于等于
    lt=...,             # 小于
    le=...,             # 小于等于
    
    # 字符串限制
    min_length=...,     # 最小长度
    max_length=...,     # 最大长度
    pattern=...,        # 正则表达式
    
    # 其他
    frozen=True,        # 不可变
    exclude=True,       # 导出时排除
)
```

---

**3. ConfigDict - 模型配置**

```python
from pydantic import BaseModel, ConfigDict

class StrictModel(BaseModel):
    model_config = ConfigDict(
        # 严格模式
        strict=True,  # 不自动类型转换
        
        # 额外字段
        extra="forbid",  # 禁止额外字段
        # extra="allow",   # 允许额外字段
        # extra="ignore",  # 忽略额外字段
        
        # 字符串处理
        str_strip_whitespace=True,  # 去除空白
        str_to_lower=True,          # 转小写
        str_to_upper=True,          # 转大写
        
        # 验证
        validate_assignment=True,   # 赋值时验证
        validate_default=True,      # 验证默认值
        
        # 任意类型
        arbitrary_types_allowed=True,  # 允许任意类型
        
        # 别名
        populate_by_name=True,  # 同时支持字段名和别名
        
        # 冻结
        frozen=True,  # 所有字段不可变
    )
    
    name: str
    age: int

# 测试
try:
    model = StrictModel(name="Alice", age="30", extra="field")
    # strict=True: TypeError (age 必须是 int)
    # extra="forbid": ValidationError (不允许 extra)
except ValidationError as e:
    print(e)
```

---

**4. @field_validator - 自定义验证**

```python
from pydantic import BaseModel, field_validator

class User(BaseModel):
    username: str
    age: int
    password: str
    confirm_password: str
    
    @field_validator('username')
    @classmethod
    def validate_username(cls, v):
        """验证用户名"""
        if len(v) < 3:
            raise ValueError('用户名至少3个字符')
        if not v.isalnum():
            raise ValueError('用户名只能包含字母和数字')
        return v.lower()  # 转小写
    
    @field_validator('age')
    @classmethod
    def validate_age(cls, v):
        """验证年龄"""
        if v < 0 or v > 150:
            raise ValueError('年龄必须在 0-150 之间')
        return v
    
    @field_validator('password')
    @classmethod
    def validate_password(cls, v):
        """验证密码强度"""
        if len(v) < 8:
            raise ValueError('密码至少8个字符')
        if not any(c.isupper() for c in v):
            raise ValueError('密码必须包含大写字母')
        if not any(c.isdigit() for c in v):
            raise ValueError('密码必须包含数字')
        return v

# 使用
user = User(
    username="Alice123",
    age=25,
    password="Password123",
    confirm_password="Password123"
)
```

---

**5. @model_validator - 模型级验证**

```python
from pydantic import BaseModel, model_validator

class DateRange(BaseModel):
    start_date: datetime
    end_date: datetime
    
    @model_validator(mode='after')
    def validate_dates(self):
        """验证日期范围"""
        if self.end_date < self.start_date:
            raise ValueError('结束日期必须晚于开始日期')
        return self

class User(BaseModel):
    password: str
    confirm_password: str
    
    @model_validator(mode='after')
    def validate_passwords(self):
        """验证密码匹配"""
        if self.password != self.confirm_password:
            raise ValueError('两次密码不一致')
        return self
```

---

**6. 嵌套模型**

```python
from pydantic import BaseModel

class Address(BaseModel):
    street: str
    city: str
    country: str = "USA"

class User(BaseModel):
    name: str
    age: int
    address: Address  # 嵌套模型

# 使用
user = User(
    name="Alice",
    age=30,
    address={
        "street": "123 Main St",
        "city": "New York"
    }
)

print(user.address.city)  # "New York"

# 转换为字典（递归）
print(user.model_dump())
# {
#     'name': 'Alice',
#     'age': 30,
#     'address': {
#         'street': '123 Main St',
#         'city': 'New York',
#         'country': 'USA'
#     }
# }
```

---

**7. JSON Schema 生成**

```python
from pydantic import BaseModel, Field

class Product(BaseModel):
    name: str = Field(description="Product name")
    price: float = Field(gt=0, description="Price")
    stock: int = Field(ge=0, description="Stock quantity")

# 生成 JSON Schema
schema = Product.model_json_schema()
print(schema)
# {
#     'type': 'object',
#     'properties': {
#         'name': {'type': 'string', 'title': 'Name', 'description': 'Product name'},
#         'price': {'type': 'number', 'exclusiveMinimum': 0, 'description': 'Price'},
#         'stock': {'type': 'integer', 'minimum': 0, 'description': 'Stock quantity'}
#     },
#     'required': ['name', 'price', 'stock']
# }
```

---

#### **实际应用场景**

**场景 1：API 请求验证**

```python
from pydantic import BaseModel, Field, EmailStr
from fastapi import FastAPI, HTTPException

app = FastAPI()

class CreateUserRequest(BaseModel):
    username: str = Field(min_length=3, max_length=50)
    email: EmailStr  # 自动验证邮箱
    age: int = Field(ge=18, le=120)
    password: str = Field(min_length=8)

@app.post("/users")
async def create_user(user: CreateUserRequest):
    # pydantic 自动验证，无效数据返回 422
    return {"message": f"User {user.username} created"}

# 测试
# POST /users
# {
#     "username": "ab",  # ❌ 太短
#     "email": "invalid",  # ❌ 无效邮箱
#     "age": 15,  # ❌ 小于18
#     "password": "123"  # ❌ 太短
# }
# 返回详细的验证错误
```

---

**场景 2：配置管理**

```python
from pydantic_settings import BaseSettings

class Settings(BaseSettings):
    """应用配置（从环境变量读取）"""
    
    # 数据库
    database_url: str = Field(alias="DATABASE_URL")
    db_pool_size: int = Field(default=10, ge=1, le=100)
    
    # Redis
    redis_host: str = "localhost"
    redis_port: int = Field(default=6379, ge=1, le=65535)
    
    # API
    api_key: str
    debug: bool = False
    
    model_config = ConfigDict(
        env_file=".env",  # 从 .env 文件读取
        case_sensitive=False,  # 不区分大小写
    )

# 使用
settings = Settings()  # 自动从环境变量读取
print(settings.database_url)
```

---

**场景 3：数据转换和序列化**

```python
from pydantic import BaseModel, field_serializer
from datetime import datetime

class Event(BaseModel):
    name: str
    created_at: datetime
    metadata: dict
    
    @field_serializer('created_at')
    def serialize_datetime(self, dt: datetime) -> str:
        """自定义序列化"""
        return dt.isoformat()
    
    @field_serializer('metadata')
    def serialize_metadata(self, data: dict) -> str:
        """序列化为 JSON 字符串"""
        return json.dumps(data)

# 使用
event = Event(
    name="Test",
    created_at=datetime.now(),
    metadata={"key": "value"}
)

print(event.model_dump())
# {
#     'name': 'Test',
#     'created_at': '2025-01-20T10:00:00',
#     'metadata': '{"key":"value"}'
# }
```

---

**常见陷阱**

**陷阱 1：可变默认值**

```python
from pydantic import BaseModel, Field

# ❌ 错误：可变默认值
class BadModel(BaseModel):
    tags: list = []  # 所有实例共享同一个列表！

m1 = BadModel()
m1.tags.append("tag1")
m2 = BadModel()
print(m2.tags)  # ['tag1'] ❌ 受影响

# ✅ 正确：使用 default_factory
class GoodModel(BaseModel):
    tags: list[str] = Field(default_factory=list)

m1 = GoodModel()
m1.tags.append("tag1")
m2 = GoodModel()
print(m2.tags)  # [] ✅ 独立的列表
```

---

**陷阱 2：混淆 ... 和 None**

```python
from pydantic import BaseModel, Field

class Model(BaseModel):
    # 必填字段
    required_field: str = Field(...)
    #                          ^^^^ 必须提供
    
    # 可选字段（有默认值 None）
    optional_field: str | None = None
    #                           ^^^^ 可以不提供
    
    # 可选但必填（必须显式传 None）
    explicit_none: str | None = Field(...)
    #                                ^^^^ 必须提供（可以是 None）

# 测试
Model(required_field="value", explicit_none=None)  # ✅
# Model(required_field="value")  # ❌ 缺少 explicit_none
```

---

**陷阱 3：类型转换的限制**

```python
from pydantic import BaseModel, ConfigDict

class AutoConvert(BaseModel):
    age: int

class StrictModel(BaseModel):
    model_config = ConfigDict(strict=True)
    age: int

# 自动转换
AutoConvert(age="30")  # ✅ 转换为 30

# 严格模式
try:
    StrictModel(age="30")  # ❌ ValidationError
except ValidationError:
    print("严格模式不自动转换")
```

---

#### **总结**

**核心概念**

| 概念                  | 作用        | 关键点             |
| --------------------- | ----------- | ------------------ |
| `BaseModel`           | 基础模型类  | 所有模型继承       |
| `Field()`             | 字段配置    | 验证、描述、默认值 |
| `ConfigDict`          | 模型配置    | 行为控制           |
| `@field_validator`    | 字段验证器  | 自定义验证逻辑     |
| `@model_validator`    | 模型验证器  | 跨字段验证         |
| `model_dump()`        | 转为字典    | 序列化             |
| `model_json_schema()` | 生成 Schema | API 文档           |

**最佳实践**

1. **使用类型注解** - 自动验证和 IDE 提示
2. **Field() 添加描述** - 自动生成文档
3. **可变默认值用 default_factory** - 避免共享
4. **自定义验证器** - 复杂业务逻辑
5. **ConfigDict 控制行为** - 灵活配置

### **HTTP 客户端**

### 2.`requests` - 同步 HTTP 请求

**什么是 requests？**

- Python 最流行的 **HTTP 客户端库**
- 简洁优雅的 API
- 支持所有 HTTP 方法（GET、POST、PUT、DELETE 等）
- 需要安装：`pip install requests`

**为什么用 requests？**

```python
import requests

# 传统 urllib（复杂）
import urllib.request
import json as json_lib

req = urllib.request.Request(
    "https://api.example.com/users",
    data=json_lib.dumps({"name": "Alice"}).encode(),
    headers={"Content-Type": "application/json"}
)
response = urllib.request.urlopen(req)
data = json_lib.loads(response.read().decode())

# requests（简洁）
response = requests.post(
    "https://api.example.com/users",
    json={"name": "Alice"}
)
data = response.json()

# 优势：
# 1. API 简洁直观
# 2. 自动处理 JSON
# 3. 自动处理编码
# 4. 强大的会话管理
# 5. 内置连接池
```

---

####  **核心功能速查表**

| 方法/功能                                                    | 作用        | 示例                                                         |
| ------------------------------------------------------------ | ----------- | ------------------------------------------------------------ |
| [get()](cci:1://file:///d:/%E8%BD%AC%E7%A0%81/AI-all/AutoGPT/autogpt_platform/backend/backend/integrations/creds_manager.py:73:4-91:26) | GET 请求    | [requests.get(url)](cci:1://file:///d:/%E8%BD%AC%E7%A0%81/AI-all/AutoGPT/autogpt_platform/backend/backend/integrations/creds_manager.py:73:4-91:26) |
| `post()`                                                     | POST 请求   | `requests.post(url, json=data)`                              |
| `put()`                                                      | PUT 请求    | `requests.put(url, json=data)`                               |
| [delete()](cci:1://file:///d:/%E8%BD%AC%E7%A0%81/AI-all/AutoGPT/autogpt_platform/backend/backend/integrations/creds_manager.py:165:4-167:72) | DELETE 请求 | [requests.delete(url)](cci:1://file:///d:/%E8%BD%AC%E7%A0%81/AI-all/AutoGPT/autogpt_platform/backend/backend/integrations/creds_manager.py:165:4-167:72) |
| `Session()`                                                  | 会话管理    | 保持 cookie、连接池                                          |
| `headers`                                                    | 请求头      | `headers={'Auth': 'token'}`                                  |
| `timeout`                                                    | 超时设置    | `timeout=5`                                                  |

---

#### **核心功能详解**

**1. 基础 GET 请求**

```python
import requests

# 最简单的 GET 请求
response = requests.get('https://api.github.com')

# 查看响应
print(response.status_code)  # 200
print(response.headers['Content-Type'])  # application/json
print(response.text)  # 响应文本
print(response.json())  # 自动解析 JSON

# 带参数的 GET 请求
params = {'q': 'python', 'sort': 'stars'}
response = requests.get('https://api.github.com/search/repositories', params=params)
# 实际请求：https://api.github.com/search/repositories?q=python&sort=stars

# 查看最终 URL
print(response.url)
```

---

**2. POST 请求**

```python
import requests

# 发送 JSON 数据
data = {'name': 'Alice', 'age': 30}
response = requests.post(
    'https://api.example.com/users',
    json=data  # 自动设置 Content-Type: application/json
)

# 发送表单数据
form_data = {'username': 'alice', 'password': 'secret'}
response = requests.post(
    'https://api.example.com/login',
    data=form_data  # Content-Type: application/x-www-form-urlencoded
)

# 发送文件
files = {'file': open('report.pdf', 'rb')}
response = requests.post(
    'https://api.example.com/upload',
    files=files
)

# 复杂的多部分表单
files = {
    'file': ('report.pdf', open('report.pdf', 'rb'), 'application/pdf'),
    'data': (None, '{"key": "value"}', 'application/json')
}
response = requests.post(url, files=files)
```

---

**3. 请求头（Headers）**

```python
import requests

# 自定义请求头
headers = {
    'User-Agent': 'MyApp/1.0',
    'Authorization': 'Bearer YOUR_TOKEN',
    'Accept': 'application/json',
    'X-Custom-Header': 'custom-value'
}

response = requests.get(
    'https://api.example.com/data',
    headers=headers
)

# 查看请求头
print(response.request.headers)

# 查看响应头
print(response.headers)
print(response.headers['Content-Type'])
```

---

**4. 认证（Authentication）**

```python
import requests
from requests.auth import HTTPBasicAuth

# 基础认证（方式1）
response = requests.get(
    'https://api.example.com/user',
    auth=('username', 'password')
)

# 基础认证（方式2）
response = requests.get(
    'https://api.example.com/user',
    auth=HTTPBasicAuth('username', 'password')
)

# Bearer Token
headers = {'Authorization': 'Bearer YOUR_ACCESS_TOKEN'}
response = requests.get('https://api.example.com/protected', headers=headers)

# API Key
headers = {'X-API-Key': 'your-api-key'}
response = requests.get('https://api.example.com/data', headers=headers)
```

---

**5. 超时设置**

```python
import requests
from requests.exceptions import Timeout

# 设置超时（秒）
try:
    response = requests.get('https://api.example.com', timeout=5)
    #                                                   ^^^^^^^^^ 5秒超时
except Timeout:
    print("请求超时！")

# 分别设置连接超时和读取超时
response = requests.get(
    'https://api.example.com',
    timeout=(3.05, 27)  # (连接超时, 读取超时)
)

# 无限等待（不推荐）
response = requests.get('https://api.example.com', timeout=None)
```

---

**6. Session - 会话管理**

```python
import requests

# 使用 Session 保持 cookies 和连接池
session = requests.Session()

# 设置默认头
session.headers.update({
    'User-Agent': 'MyApp/1.0',
    'Authorization': 'Bearer TOKEN'
})

# 登录
response = session.post('https://api.example.com/login', json={
    'username': 'alice',
    'password': 'secret'
})

# 后续请求自动携带 cookies
response = session.get('https://api.example.com/profile')
response = session.get('https://api.example.com/data')

# 关闭 session
session.close()

# 推荐：使用上下文管理器
with requests.Session() as session:
    session.headers.update({'Authorization': 'Bearer TOKEN'})
    response = session.get('https://api.example.com/data')
    # 自动关闭
```

---

**7. 错误处理**

```python
import requests
from requests.exceptions import (
    HTTPError, 
    ConnectionError, 
    Timeout,
    RequestException
)

try:
    response = requests.get('https://api.example.com/data', timeout=5)
    
    # 检查状态码（如果不是 2xx，抛出异常）
    response.raise_for_status()
    #        ^^^^^^^^^^^^^^^^ 4xx, 5xx 会抛出 HTTPError
    
    data = response.json()
    
except HTTPError as e:
    print(f"HTTP错误: {e.response.status_code}")
    print(e.response.text)
    
except ConnectionError:
    print("连接错误！")
    
except Timeout:
    print("请求超时！")
    
except RequestException as e:
    print(f"请求失败: {e}")

# 手动检查状态码
response = requests.get('https://api.example.com/data')
if response.status_code == 200:
    print("成功")
elif response.status_code == 404:
    print("未找到")
elif response.status_code >= 500:
    print("服务器错误")
```

---

**8. 响应内容处理**

```python
import requests

response = requests.get('https://api.example.com/data')

# JSON 响应
data = response.json()  # 自动解析 JSON

# 文本响应
text = response.text  # str 类型

# 二进制响应
content = response.content  # bytes 类型

# 流式下载大文件
response = requests.get('https://example.com/large-file.zip', stream=True)
with open('large-file.zip', 'wb') as f:
    for chunk in response.iter_content(chunk_size=8192):
        f.write(chunk)

# 检查响应编码
print(response.encoding)  # 'utf-8'
response.encoding = 'ISO-8859-1'  # 修改编码
```

---

#### **实际应用场景**

**场景 1：调用 REST API**

```python
import requests

class GitHubAPI:
    BASE_URL = 'https://api.github.com'
    
    def __init__(self, token):
        self.session = requests.Session()
        self.session.headers.update({
            'Authorization': f'token {token}',
            'Accept': 'application/vnd.github.v3+json'
        })
    
    def get_user(self, username):
        """获取用户信息"""
        response = self.session.get(f'{self.BASE_URL}/users/{username}')
        response.raise_for_status()
        return response.json()
    
    def get_repos(self, username):
        """获取用户仓库列表"""
        response = self.session.get(
            f'{self.BASE_URL}/users/{username}/repos',
            params={'sort': 'updated', 'per_page': 10}
        )
        response.raise_for_status()
        return response.json()
    
    def create_issue(self, owner, repo, title, body):
        """创建 Issue"""
        response = self.session.post(
            f'{self.BASE_URL}/repos/{owner}/{repo}/issues',
            json={'title': title, 'body': body}
        )
        response.raise_for_status()
        return response.json()

# 使用
api = GitHubAPI(token='YOUR_TOKEN')
user = api.get_user('octocat')
print(f"Name: {user['name']}, Followers: {user['followers']}")
```

---

**场景 2：下载文件**

```python
import requests
from pathlib import Path

def download_file(url, save_path):
    """下载文件（带进度）"""
    response = requests.get(url, stream=True)
    response.raise_for_status()
    
    total_size = int(response.headers.get('content-length', 0))
    
    with open(save_path, 'wb') as f:
        downloaded = 0
        for chunk in response.iter_content(chunk_size=8192):
            if chunk:
                f.write(chunk)
                downloaded += len(chunk)
                
                # 显示进度
                if total_size:
                    percent = (downloaded / total_size) * 100
                    print(f'\r下载进度: {percent:.1f}%', end='')
    
    print(f'\n下载完成: {save_path}')

# 使用
download_file(
    'https://example.com/large-file.zip',
    'downloads/file.zip'
)
```

---

**场景 3：重试机制**

```python
import requests
from requests.adapters import HTTPAdapter
from requests.packages.urllib3.util.retry import Retry

def create_session_with_retry():
    """创建带重试的 session"""
    session = requests.Session()
    
    # 配置重试策略
    retry_strategy = Retry(
        total=3,  # 最多重试3次
        backoff_factor=1,  # 重试间隔：1, 2, 4 秒
        status_forcelist=[429, 500, 502, 503, 504],  # 这些状态码重试
        allowed_methods=["HEAD", "GET", "OPTIONS", "POST"]
    )
    
    adapter = HTTPAdapter(max_retries=retry_strategy)
    session.mount("http://", adapter)
    session.mount("https://", adapter)
    
    return session

# 使用
session = create_session_with_retry()
response = session.get('https://api.example.com/unstable-endpoint')
```

---

**场景 4：代理设置**

```python
import requests

# 使用代理
proxies = {
    'http': 'http://proxy.example.com:8080',
    'https': 'http://proxy.example.com:8080',
}

response = requests.get('https://api.example.com', proxies=proxies)

# 需要认证的代理
proxies = {
    'http': 'http://user:pass@proxy.example.com:8080',
    'https': 'http://user:pass@proxy.example.com:8080',
}

# Session 级别的代理
session = requests.Session()
session.proxies.update(proxies)
```

---

#### **requests vs httpx vs aiohttp**

| 特性         | requests | httpx         | aiohttp    |
| ------------ | -------- | ------------- | ---------- |
| **同步支持** | ✅        | ✅             | ❌          |
| **异步支持** | ❌        | ✅             | ✅          |
| **HTTP/2**   | ❌        | ✅             | ❌          |
| **API 风格** | 简单     | 类似 requests | 不同风格   |
| **性能**     | 中等     | 高            | 最高       |
| **社区**     | 最大     | 增长中        | 大         |
| **推荐场景** | 同步脚本 | 现代应用      | 高性能异步 |

#### **常见陷阱**

**陷阱 1：忘记关闭 session**

```python
# ❌ 错误：资源泄漏
session = requests.Session()
response = session.get('https://api.example.com')
# 忘记关闭

# ✅ 正确：使用上下文管理器
with requests.Session() as session:
    response = session.get('https://api.example.com')
# 自动关闭
```

---

**陷阱 2：没有设置超时**

```python
# ❌ 危险：可能永久挂起
response = requests.get('https://slow-api.example.com')

# ✅ 安全：设置超时
response = requests.get('https://slow-api.example.com', timeout=10)
```

---

**陷阱 3：不检查状态码**

```python
# ❌ 错误：不检查
response = requests.get('https://api.example.com/data')
data = response.json()  # 可能 404 或 500

# ✅ 正确：检查状态
response = requests.get('https://api.example.com/data')
response.raise_for_status()  # 抛出异常
data = response.json()
```

---

#### **总结**

**核心方法**

| 方法                                                         | 用途      | 示例                                                         |
| ------------------------------------------------------------ | --------- | ------------------------------------------------------------ |
| [get()](cci:1://file:///d:/%E8%BD%AC%E7%A0%81/AI-all/AutoGPT/autogpt_platform/backend/backend/integrations/creds_manager.py:73:4-91:26) | GET 请求  | [requests.get(url)](cci:1://file:///d:/%E8%BD%AC%E7%A0%81/AI-all/AutoGPT/autogpt_platform/backend/backend/integrations/creds_manager.py:73:4-91:26) |
| `post()`                                                     | POST 请求 | `requests.post(url, json=data)`                              |
| `Session()`                                                  | 会话管理  | 保持连接和 cookies                                           |
| `raise_for_status()`                                         | 检查错误  | 抛出 HTTP 异常                                               |

**最佳实践**

1. **总是设置超时** - 避免挂起
2. **使用 Session** - 提高性能
3. **检查状态码** - 处理错误
4. **使用上下文管理器** - 自动清理资源
5. **处理异常** - 网络可能失败

### 3.`aiohttp` - 异步 HTTP 请求

**什么是 aiohttp？**

- Python **异步 HTTP 客户端/服务器**框架
- 基于 **asyncio**，完全异步
- 支持客户端和服务器
- AutoGPT Platform 的**核心 HTTP 库**
- 需要安装：`pip install aiohttp`

**为什么用 aiohttp？**

```python
import asyncio
import aiohttp

# 同步 requests（阻塞）
import requests
response = requests.get('https://api.example.com/user/1')
response = requests.get('https://api.example.com/user/2')
response = requests.get('https://api.example.com/user/3')
# 总时间：3秒（串行）

# 异步 aiohttp（并发）
async def fetch_users():
    async with aiohttp.ClientSession() as session:
        tasks = [
            session.get('https://api.example.com/user/1'),
            session.get('https://api.example.com/user/2'),
            session.get('https://api.example.com/user/3'),
        ]
        responses = await asyncio.gather(*tasks)
        # 总时间：1秒（并发）
        return responses

# 优势：
# 1. 高并发（同时处理大量请求）
# 2. 非阻塞（不占用 CPU）
# 3. 性能强大
# 4. 适合 I/O 密集型任务
```

---

#### **核心概念速查表**

| 类/方法                                                      | 作用            | 使用场景 |
| ------------------------------------------------------------ | --------------- | -------- |
| `ClientSession`                                              | HTTP 客户端会话 | 发送请求 |
| [session.get()](cci:1://file:///d:/%E8%BD%AC%E7%A0%81/AI-all/AutoGPT/autogpt_platform/backend/backend/integrations/creds_manager.py:73:4-91:26) | GET 请求        | 获取数据 |
| `session.post()`                                             | POST 请求       | 提交数据 |
| `response.text()`                                            | 获取文本        | 异步读取 |
| `response.json()`                                            | 获取 JSON       | 异步解析 |
| `FormData`                                                   | 表单数据        | 文件上传 |
| `TCPConnector`                                               | 连接池配置      | 性能优化 |

---

> ## **AutoGPT Platform 中的实际使用**
>
> #### **案例 1：Requests 包装类（SSRF 防护）**
>
> ```python
> # backend/util/request.py
> import aiohttp
> from aiohttp import FormData
> 
> class Requests:
>     """aiohttp 的安全包装器，防止 SSRF 攻击"""
>     
>     async def _request(
>         self,
>         method: str,
>         url: str,
>         *,
>         headers: dict | None = None,
>         json: Any | None = None,
>         files: list | None = None,
>         **kwargs
>     ) -> Response:
>         # 验证 URL 安全性
>         parsed_url, is_trusted, ip_addresses = await validate_url(
>             url, self.trusted_origins
>         )
>         
>         # 配置连接器（用于 SSRF 防护）
>         connector = None
>         if not is_trusted:
>             resolver = HostResolver(
>                 ssl_hostname=hostname, 
>                 ip_addresses=ip_addresses
>             )
>             connector = aiohttp.TCPConnector(
>                 resolver=resolver, 
>                 ssl=ssl.create_default_context()
>             )
>         
>         # 创建会话并发送请求
>         async with aiohttp.ClientSession(connector=connector) as session:
>             async with session.request(
>                 method,
>                 parsed_url.geturl(),
>                 headers=headers,
>                 json=json,
>                 **kwargs
>             ) as response:
>                 # 检查状态码
>                 response.raise_for_status()
>                 
>                 # 读取响应体
>                 return Response(
>                     response=response,
>                     url=url,
>                     body=await response.read()
>                 )
> ```
>
> ---
>
> #### **案例 2：自定义 DNS 解析器**
>
> ```python
> # backend/util/request.py
> import aiohttp
> from aiohttp import abc
> 
> class HostResolver(abc.AbstractResolver):
>     """自定义解析器，用于 SSRF 防护"""
>     
>     def __init__(self, ssl_hostname: str, ip_addresses: list[str]):
>         self.ssl_hostname = ssl_hostname
>         self.ip_addresses = ip_addresses
>         self._default = aiohttp.AsyncResolver()
>     
>     async def resolve(self, host, port=0, family=socket.AF_INET):
>         """解析主机名到 IP 地址"""
>         if host == self.ssl_hostname:
>             # 返回预验证的 IP 地址
>             results = []
>             for ip in self.ip_addresses:
>                 results.append({
>                     "hostname": self.ssl_hostname,
>                     "host": ip,  # 实际连接的 IP
>                     "port": port,
>                     "family": family,
>                 })
>             return results
>         # 其他主机使用默认解析器
>         return await self._default.resolve(host, port, family)
> ```
>
> ---
>
> #### **案例 3：Response 包装类**
>
> ```python
> # backend/util/request.py
> ClientResponse = aiohttp.ClientResponse
> 
> class Response:
>     """aiohttp.ClientResponse 的缓冲包装器"""
>     
>     def __init__(
>         self, 
>         response: ClientResponse, 
>         url: str, 
>         body: bytes
>     ):
>         self._response = response
>         self.url = url
>         self._body = body
>     
>     @property
>     def status(self) -> int:
>         return self._response.status
>     
>     @property
>     def ok(self) -> bool:
>         return 200 <= self.status < 300
>     
>     @property
>     def headers(self):
>         return self._response.headers
>     
>     async def text(self) -> str:
>         """获取文本内容"""
>         return self._body.decode('utf-8')
>     
>     async def json(self) -> dict:
>         """解析 JSON"""
>         import json
>         return json.loads(self._body.decode('utf-8'))
> ```
>

#### 核心概念详解

**1. ClientSession 基础**

```python
import aiohttp
import asyncio

async def fetch(url):
    # 创建会话
    async with aiohttp.ClientSession() as session:
        # 发送 GET 请求
        async with session.get(url) as response:
            print(f"状态码: {response.status}")
            print(f"响应头: {response.headers}")
            
            # 读取响应体
            text = await response.text()
            print(f"内容: {text}")
            
            return text

# 运行
asyncio.run(fetch('https://api.github.com'))

# 重要：
# 1. 必须使用 async with（异步上下文管理器）
# 2. response.text() 是异步的，需要 await
# 3. session 会自动管理连接池
```

---

**2. 各种 HTTP 方法**

```python
import aiohttp

async def http_methods():
    async with aiohttp.ClientSession() as session:
        # GET 请求
        async with session.get('https://api.example.com/users') as resp:
            data = await resp.json()
        
        # POST 请求（JSON）
        async with session.post(
            'https://api.example.com/users',
            json={'name': 'Alice', 'age': 30}
        ) as resp:
            result = await resp.json()
        
        # POST 请求（表单）
        async with session.post(
            'https://api.example.com/login',
            data={'username': 'alice', 'password': 'secret'}
        ) as resp:
            result = await resp.json()
        
        # PUT 请求
        async with session.put(
            'https://api.example.com/users/1',
            json={'name': 'Alice Updated'}
        ) as resp:
            result = await resp.json()
        
        # DELETE 请求
        async with session.delete(
            'https://api.example.com/users/1'
        ) as resp:
            result = await resp.json()
        
        # PATCH 请求
        async with session.patch(
            'https://api.example.com/users/1',
            json={'age': 31}
        ) as resp:
            result = await resp.json()
```

---

**3. 请求头和参数**

```python
import aiohttp

async def with_headers_params():
    async with aiohttp.ClientSession() as session:
        # 请求头
        headers = {
            'User-Agent': 'MyApp/1.0',
            'Authorization': 'Bearer YOUR_TOKEN',
            'Accept': 'application/json'
        }
        
        # URL 参数
        params = {
            'q': 'python',
            'sort': 'stars',
            'page': 1
        }
        
        async with session.get(
            'https://api.github.com/search/repositories',
            headers=headers,
            params=params
        ) as resp:
            data = await resp.json()
            return data

# Session 级别的默认头
async def session_headers():
    headers = {'Authorization': 'Bearer TOKEN'}
    
    async with aiohttp.ClientSession(headers=headers) as session:
        # 所有请求都会带上这个头
        async with session.get('https://api.example.com/data') as resp:
            data = await resp.json()
```

---

**4. 超时设置**

```python
import aiohttp
import asyncio

async def with_timeout():
    # 超时配置
    timeout = aiohttp.ClientTimeout(
        total=30,      # 总超时（秒）
        connect=10,    # 连接超时
        sock_read=10,  # 读取超时
    )
    
    async with aiohttp.ClientSession(timeout=timeout) as session:
        try:
            async with session.get('https://slow-api.example.com') as resp:
                data = await resp.json()
        except asyncio.TimeoutError:
            print("请求超时！")

# 单个请求超时
async def request_timeout():
    timeout = aiohttp.ClientTimeout(total=5)
    
    async with aiohttp.ClientSession() as session:
        async with session.get(
            'https://api.example.com',
            timeout=timeout
        ) as resp:
            data = await resp.json()
```

---

**5. 文件上传**

```python
import aiohttp
from aiohttp import FormData

async def upload_file():
    # 方式1：使用 FormData
    data = FormData()
    data.add_field('file',
                   open('report.pdf', 'rb'),
                   filename='report.pdf',
                   content_type='application/pdf')
    data.add_field('title', 'My Report')
    
    async with aiohttp.ClientSession() as session:
        async with session.post(
            'https://api.example.com/upload',
            data=data
        ) as resp:
            result = await resp.json()
    
    # 方式2：简化版
    files = {'file': open('image.png', 'rb')}
    async with aiohttp.ClientSession() as session:
        async with session.post(
            'https://api.example.com/upload',
            data=files
        ) as resp:
            result = await resp.json()

# 多文件上传
async def upload_multiple():
    data = FormData()
    data.add_field('file1', open('doc1.pdf', 'rb'))
    data.add_field('file2', open('doc2.pdf', 'rb'))
    data.add_field('description', 'Multiple documents')
    
    async with aiohttp.ClientSession() as session:
        async with session.post(url, data=data) as resp:
            result = await resp.json()
```

---

**6. 认证**

```python
import aiohttp

async def basic_auth():
    # HTTP 基础认证
    auth = aiohttp.BasicAuth('username', 'password')
    
    async with aiohttp.ClientSession() as session:
        async with session.get(
            'https://api.example.com/protected',
            auth=auth
        ) as resp:
            data = await resp.json()

# Bearer Token
async def bearer_token():
    headers = {'Authorization': 'Bearer YOUR_ACCESS_TOKEN'}
    
    async with aiohttp.ClientSession(headers=headers) as session:
        async with session.get('https://api.example.com/data') as resp:
            data = await resp.json()

# API Key
async def api_key_auth():
    headers = {'X-API-Key': 'your-api-key'}
    
    async with aiohttp.ClientSession(headers=headers) as session:
        async with session.get('https://api.example.com/data') as resp:
            data = await resp.json()
```

---

**7. 连接池配置（TCPConnector）**

```python
import aiohttp

async def with_connector():
    # 配置连接器
    connector = aiohttp.TCPConnector(
        limit=100,              # 总连接数限制
        limit_per_host=30,      # 每个主机的连接数
        ttl_dns_cache=300,      # DNS 缓存时间（秒）
        use_dns_cache=True,     # 使用 DNS 缓存
        keepalive_timeout=30,   # Keep-Alive 超时
    )
    
    async with aiohttp.ClientSession(connector=connector) as session:
        # 复用连接
        tasks = [
            session.get(f'https://api.example.com/user/{i}')
            for i in range(100)
        ]
        responses = await asyncio.gather(*tasks)

# SSL 配置
async def ssl_config():
    import ssl
    
    ssl_context = ssl.create_default_context()
    # 禁用证书验证（不推荐，仅用于测试）
    # ssl_context.check_hostname = False
    # ssl_context.verify_mode = ssl.CERT_NONE
    
    connector = aiohttp.TCPConnector(ssl=ssl_context)
    
    async with aiohttp.ClientSession(connector=connector) as session:
        async with session.get('https://api.example.com') as resp:
            data = await resp.json()
```

---

**8. 并发请求**

```python
import aiohttp
import asyncio

async def fetch_one(session, url):
    """获取单个 URL"""
    async with session.get(url) as response:
        return await response.json()

async def fetch_many(urls):
    """并发获取多个 URL"""
    async with aiohttp.ClientSession() as session:
        tasks = [fetch_one(session, url) for url in urls]
        results = await asyncio.gather(*tasks)
        return results

# 使用
urls = [
    'https://api.example.com/user/1',
    'https://api.example.com/user/2',
    'https://api.example.com/user/3',
]
results = asyncio.run(fetch_many(urls))

# 限制并发数
from asyncio import Semaphore

async def fetch_with_limit(urls, max_concurrent=5):
    """限制并发数量"""
    sem = Semaphore(max_concurrent)
    
    async def fetch(session, url):
        async with sem:  # 限制并发
            async with session.get(url) as response:
                return await response.json()
    
    async with aiohttp.ClientSession() as session:
        tasks = [fetch(session, url) for url in urls]
        return await asyncio.gather(*tasks)
```

---

#### **实际应用场景**

**场景 1：构建 API 客户端**

```python
import aiohttp
from typing import Dict, List

class GitHubAsyncAPI:
    BASE_URL = 'https://api.github.com'
    
    def __init__(self, token: str):
        self.token = token
        self.session = None
    
    async def __aenter__(self):
        """进入上下文时创建 session"""
        headers = {
            'Authorization': f'token {self.token}',
            'Accept': 'application/vnd.github.v3+json'
        }
        self.session = aiohttp.ClientSession(
            headers=headers,
            timeout=aiohttp.ClientTimeout(total=30)
        )
        return self
    
    async def __aexit__(self, *args):
        """退出时关闭 session"""
        if self.session:
            await self.session.close()
    
    async def get_user(self, username: str) -> Dict:
        """获取用户信息"""
        async with self.session.get(f'{self.BASE_URL}/users/{username}') as resp:
            resp.raise_for_status()
            return await resp.json()
    
    async def get_repos(self, username: str) -> List[Dict]:
        """获取用户仓库"""
        async with self.session.get(
            f'{self.BASE_URL}/users/{username}/repos',
            params={'sort': 'updated', 'per_page': 10}
        ) as resp:
            resp.raise_for_status()
            return await resp.json()
    
    async def create_issue(self, owner: str, repo: str, title: str, body: str) -> Dict:
        """创建 Issue"""
        async with self.session.post(
            f'{self.BASE_URL}/repos/{owner}/{repo}/issues',
            json={'title': title, 'body': body}
        ) as resp:
            resp.raise_for_status()
            return await resp.json()

# 使用
async def main():
    async with GitHubAsyncAPI(token='YOUR_TOKEN') as api:
        user = await api.get_user('octocat')
        print(f"Name: {user['name']}")
        
        repos = await api.get_repos('octocat')
        print(f"Repos: {len(repos)}")

asyncio.run(main())
```

---

**场景 2：流式下载大文件**

```python
import aiohttp
import asyncio

async def download_file(url: str, save_path: str):
    """流式下载大文件"""
    async with aiohttp.ClientSession() as session:
        async with session.get(url) as resp:
            resp.raise_for_status()
            
            total_size = int(resp.headers.get('content-length', 0))
            downloaded = 0
            
            with open(save_path, 'wb') as f:
                async for chunk in resp.content.iter_chunked(8192):
                    f.write(chunk)
                    downloaded += len(chunk)
                    
                    # 显示进度
                    if total_size:
                        percent = (downloaded / total_size) * 100
                        print(f'\r下载进度: {percent:.1f}%', end='')
            
            print(f'\n下载完成: {save_path}')

# 使用
asyncio.run(download_file(
    'https://example.com/large-file.zip',
    'downloads/file.zip'
))
```

---

**场景 3：重试机制**

```python
import aiohttp
import asyncio
from tenacity import (
    retry,
    stop_after_attempt,
    wait_exponential,
    retry_if_exception_type
)

@retry(
    stop=stop_after_attempt(3),           # 最多重试3次
    wait=wait_exponential(multiplier=1),  # 指数退避
    retry=retry_if_exception_type(aiohttp.ClientError)
)
async def fetch_with_retry(url: str):
    """带重试的请求"""
    async with aiohttp.ClientSession() as session:
        async with session.get(url) as resp:
            resp.raise_for_status()
            return await resp.json()

# AutoGPT 风格的重试
from tenacity import retry_if_result

@retry(
    wait=wait_exponential_jitter(max=300),
    retry=retry_if_result(
        lambda r: r.status in {429, 500, 502, 503, 504}
    ),
    reraise=True
)
async def fetch_with_status_retry(url: str):
    """特定状态码重试"""
    async with aiohttp.ClientSession() as session:
        async with session.get(url) as resp:
            return resp
```

---

**常见陷阱**

**陷阱 1：忘记 await**

```python
# ❌ 错误：忘记 await
async def bad_fetch():
    async with aiohttp.ClientSession() as session:
        async with session.get('https://api.example.com') as resp:
            data = resp.json()  # ❌ 返回 coroutine 对象！
            return data

# ✅ 正确：使用 await
async def good_fetch():
    async with aiohttp.ClientSession() as session:
        async with session.get('https://api.example.com') as resp:
            data = await resp.json()  # ✅
            return data
```

---

**陷阱 2：在循环外创建 session**

```python
# ❌ 错误：在事件循环外创建
session = aiohttp.ClientSession()  # ❌ RuntimeError!

async def fetch(url):
    async with session.get(url) as resp:
        return await resp.json()

# ✅ 正确：在异步函数内创建
async def main():
    async with aiohttp.ClientSession() as session:
        async with session.get(url) as resp:
            return await resp.json()
```

---

**陷阱 3：不关闭 session**

```python
# ❌ 错误：忘记关闭
async def bad():
    session = aiohttp.ClientSession()
    async with session.get(url) as resp:
        data = await resp.json()
    # 忘记 await session.close()

# ✅ 正确：使用 async with
async def good():
    async with aiohttp.ClientSession() as session:
        async with session.get(url) as resp:
            data = await resp.json()
    # 自动关闭
```

---

**陷阱 4：读取响应体多次**

```python
# ❌ 错误：响应体只能读取一次
async def bad():
    async with aiohttp.ClientSession() as session:
        async with session.get(url) as resp:
            text = await resp.text()
            json_data = await resp.json()  # ❌ 已经读取过了！

# ✅ 正确：只读取一次
async def good():
    async with aiohttp.ClientSession() as session:
        async with session.get(url) as resp:
            body = await resp.read()  # bytes
            text = body.decode('utf-8')
            import json
            json_data = json.loads(text)
```

---

#### **总结**

**核心概念**

| 概念            | 作用         | 关键点          |
| --------------- | ------------ | --------------- |
| `ClientSession` | HTTP 客户端  | 管理连接池      |
| `async with`    | 上下文管理   | 自动清理        |
| `await`         | 等待异步操作 | 所有 I/O 都需要 |
| `TCPConnector`  | 连接配置     | 性能优化        |
| `FormData`      | 文件上传     | 多部分表单      |

**最佳实践**

1. **使用 async with** - 自动管理资源
2. **复用 ClientSession** - 提高性能
3. **设置超时** - 防止挂起
4. **限制并发** - 使用 Semaphore
5. **错误处理** - raise_for_status()

**aiohttp vs requests**

| 特性     | aiohttp          | requests |
| -------- | ---------------- | -------- |
| **异步** | ✅                | ❌        |
| **并发** | 高               | 低       |
| **API**  | 需要 async/await | 简单直接 |
| **性能** | 优秀             | 中等     |
| **适用** | 高并发           | 简单脚本 |

### 4.`httpx`

**什么是 httpx？**

- **下一代** Python HTTP 客户端
- **同时支持同步和异步**（统一 API）
- 完全兼容 **requests** API（几乎无缝迁移）
- 支持 **HTTP/2** 和 **HTTP/1.1**
- AutoGPT Platform 的**主要 HTTP 库**
- 需要安装：`pip install httpx`

**为什么用 httpx？**

```python
import httpx

# 同步 API（类似 requests）
response = httpx.get('https://api.example.com')
data = response.json()

# 异步 API（类似 aiohttp）
async with httpx.AsyncClient() as client:
    response = await client.get('https://api.example.com')
    data = response.json()

# 优势：
# 1. 统一的同步/异步 API
# 2. 支持 HTTP/2（更快）
# 3. 现代化设计
# 4. 自动连接池
# 5. 类型提示完善
```

---

#### **核心概念速查表**

| 类/方法                                                      | 作用          | 同步/异步 |
| ------------------------------------------------------------ | ------------- | --------- |
| [httpx.get()](cci:1://file:///d:/%E8%BD%AC%E7%A0%81/AI-all/AutoGPT/autogpt_platform/backend/backend/util/request.py:490:4-491:62) | 快速 GET 请求 | 同步      |
| `httpx.Client()`                                             | 同步客户端    | 同步      |
| `httpx.AsyncClient()`                                        | 异步客户端    | 异步      |
| [client.request()](cci:1://file:///d:/%E8%BD%AC%E7%A0%81/AI-all/AutoGPT/autogpt_platform/backend/backend/util/request.py:309:4-340:36) | 通用请求      | 两者      |
| `Limits()`                                                   | 连接池配置    | 两者      |
| `Timeout()`                                                  | 超时配置      | 两者      |

---

> ## **AutoGPT Platform 中的实际使用**
>
> #### **案例 1：RPC 客户端（同步和异步）**
>
> ```python
> # backend/util/service.py
> import httpx
> import asyncio
> 
> class RPCClient:
>     """支持同步和异步的 RPC 客户端"""
>     
>     def __init__(self, base_url: str):
>         self.base_url = base_url
>         self._sync_clients = {}
>         self._async_clients = {}
>     
>     def _create_sync_client(self) -> httpx.Client:
>         """创建同步客户端"""
>         return httpx.Client(
>             base_url=self.base_url,
>             timeout=30.0,
>             limits=httpx.Limits(
>                 max_keepalive_connections=200,  # Keep-Alive 连接数
>                 max_connections=500,             # 最大连接数
>                 keepalive_expiry=30.0,           # Keep-Alive 过期时间
>             ),
>         )
>     
>     def _create_async_client(self) -> httpx.AsyncClient:
>         """创建异步客户端"""
>         return httpx.AsyncClient(
>             base_url=self.base_url,
>             timeout=30.0,
>             limits=httpx.Limits(
>                 max_keepalive_connections=200,
>                 max_connections=500,
>                 keepalive_expiry=30.0,
>             ),
>         )
>     
>     @property
>     def sync_client(self) -> httpx.Client:
>         """获取同步客户端（线程安全单例）"""
>         service_name = "default"
>         if client := self._sync_clients.get(service_name):
>             return client
>         return self._sync_clients.setdefault(
>             service_name, self._create_sync_client()
>         )
>     
>     @property
>     def async_client(self) -> httpx.AsyncClient:
>         """获取异步客户端（每个事件循环一个）"""
>         try:
>             loop = asyncio.get_running_loop()
>         except RuntimeError:
>             loop = None
>         
>         if client := self._async_clients.get(loop):
>             return client
>         return self._async_clients.setdefault(
>             loop, self._create_async_client()
>         )
>     
>     def call_sync(self, method: str, **kwargs):
>         """同步调用"""
>         response = self.sync_client.post(method, json=kwargs)
>         response.raise_for_status()
>         return response.json()
>     
>     async def call_async(self, method: str, **kwargs):
>         """异步调用"""
>         response = await self.async_client.post(method, json=kwargs)
>         response.raise_for_status()
>         return response.json()
> ```
>
> ---
>
> #### **案例 2：错误处理和自动重连**
>
> ```python
> # backend/util/service.py
> import httpx
> import time
> 
> class SelfHealingClient:
>     """带自动重连的客户端"""
>     
>     def __init__(self):
>         self._connection_failure_count = 0
>         self._last_client_reset = 0
>         self._clients = {}
>     
>     def _handle_connection_error(self, error: Exception):
>         """处理连接错误，实现自愈"""
>         self._connection_failure_count += 1
>         current_time = time.time()
>         
>         # 如果连续失败 3 次，且距离上次重置超过 30 秒
>         if (
>             self._connection_failure_count >= 3
>             and current_time - self._last_client_reset > 30
>         ):
>             logger.warning(
>                 f"检测到连接失败 ({self._connection_failure_count})，重建客户端"
>             )
>             
>             # 清空缓存，强制重建
>             self._clients.clear()
>             
>             # 重置计数器
>             self._connection_failure_count = 0
>             self._last_client_reset = current_time
>     
>     def _handle_response(self, response: httpx.Response):
>         """处理响应"""
>         try:
>             response.raise_for_status()
>             # 成功时重置失败计数
>             self._connection_failure_count = 0
>             return response.json()
>         
>         except httpx.HTTPStatusError as e:
>             status_code = e.response.status_code
>             
>             # 根据状态码分类处理
>             if 400 <= status_code < 500:
>                 # 客户端错误（4xx）- 不重试
>                 raise HTTPClientError(status_code, str(e))
>             elif 500 <= status_code < 600:
>                 # 服务器错误（5xx）- 允许重试
>                 raise HTTPServerError(status_code, str(e))
>             else:
>                 raise e
>     
>     def request(self, method: str, url: str, **kwargs):
>         """发送请求"""
>         try:
>             response = self.sync_client.post(url, json=kwargs)
>             return self._handle_response(response)
>         
>         except (httpx.ConnectError, httpx.ConnectTimeout) as e:
>             # 连接错误，触发自愈
>             self._handle_connection_error(e)
>             raise
> ```
>

#### **核心概念详解**

**1. 同步 API（类似 requests）**

```python
import httpx

# 快速请求（类似 requests）
response = httpx.get('https://api.github.com')
print(response.status_code)  # 200
print(response.json())

# 带参数的请求
response = httpx.get(
    'https://api.github.com/search/repositories',
    params={'q': 'python', 'sort': 'stars'}
)

# POST 请求
response = httpx.post(
    'https://api.example.com/users',
    json={'name': 'Alice', 'age': 30}
)

# 其他方法
response = httpx.put(url, json=data)
response = httpx.patch(url, json=data)
response = httpx.delete(url)
response = httpx.head(url)
response = httpx.options(url)
```

---

**2. 异步 API**

```python
import httpx
import asyncio

# 异步请求
async def fetch_data():
    async with httpx.AsyncClient() as client:
        response = await client.get('https://api.github.com')
        return response.json()

# 运行
data = asyncio.run(fetch_data())

# 并发请求
async def fetch_many():
    async with httpx.AsyncClient() as client:
        tasks = [
            client.get(f'https://api.example.com/user/{i}')
            for i in range(10)
        ]
        responses = await asyncio.gather(*tasks)
        return [r.json() for r in responses]

asyncio.run(fetch_many())
```

---

**3. Client 配置**

```python
import httpx

# 同步客户端
client = httpx.Client(
    base_url='https://api.example.com',
    headers={'Authorization': 'Bearer TOKEN'},
    timeout=30.0,
    limits=httpx.Limits(
        max_keepalive_connections=20,
        max_connections=100,
    ),
    follow_redirects=True,
)

# 使用
response = client.get('/users')  # 自动拼接 base_url
data = response.json()

# 记得关闭
client.close()

# 推荐：使用上下文管理器
with httpx.Client() as client:
    response = client.get('https://api.example.com')
# 自动关闭

# 异步客户端
async with httpx.AsyncClient(
    base_url='https://api.example.com',
    timeout=30.0
) as client:
    response = await client.get('/users')
```

---

**4. 超时配置**

```python
import httpx

# 单一超时值（秒）
client = httpx.Client(timeout=10.0)

# 详细超时配置
timeout = httpx.Timeout(
    connect=5.0,   # 连接超时
    read=10.0,     # 读取超时
    write=10.0,    # 写入超时
    pool=5.0       # 连接池超时
)
client = httpx.Client(timeout=timeout)

# 无限超时（不推荐）
client = httpx.Client(timeout=None)

# 单个请求的超时
response = client.get(url, timeout=5.0)
```

---

**5. 连接池配置（Limits）**

```python
import httpx

# 连接池限制
limits = httpx.Limits(
    max_keepalive_connections=20,  # Keep-Alive 连接数
    max_connections=100,            # 最大连接数
    keepalive_expiry=30.0,          # Keep-Alive 过期时间（秒）
)

client = httpx.Client(limits=limits)

# AutoGPT 的高性能配置
limits = httpx.Limits(
    max_keepalive_connections=200,  # 10倍默认值
    max_connections=500,             # 高并发
    keepalive_expiry=30.0,           # 保持连接更久
)

async_client = httpx.AsyncClient(limits=limits)
```

---

**6. HTTP/2 支持**

```python
import httpx

# 启用 HTTP/2
client = httpx.Client(http2=True)

response = client.get('https://http2.golang.org/reqinfo')
print(response.http_version)  # "HTTP/2"

# 异步客户端也支持
async with httpx.AsyncClient(http2=True) as client:
    response = await client.get('https://http2.golang.org/reqinfo')
    print(response.http_version)
```

---

**7. 请求和响应对象**

```python
import httpx

response = httpx.get('https://api.github.com')

# 响应属性
print(response.status_code)      # 200
print(response.headers)          # 响应头
print(response.text)             # 文本内容
print(response.content)          # 字节内容
print(response.json())           # JSON 解析
print(response.url)              # 最终 URL
print(response.http_version)     # HTTP 版本
print(response.encoding)         # 编码
print(response.is_redirect)      # 是否重定向
print(response.is_error)         # 是否错误

# 检查状态
response.raise_for_status()      # 4xx, 5xx 抛出异常

# 请求信息
print(response.request.url)      # 请求 URL
print(response.request.method)   # 请求方法
print(response.request.headers)  # 请求头
```

---

**8. 流式响应**

```python
import httpx

# 流式下载
with httpx.stream('GET', 'https://example.com/large-file.zip') as response:
    total = int(response.headers.get('content-length', 0))
    downloaded = 0
    
    with open('large-file.zip', 'wb') as f:
        for chunk in response.iter_bytes(chunk_size=8192):
            f.write(chunk)
            downloaded += len(chunk)
            print(f'\r{downloaded}/{total}', end='')

# 异步流式
async with httpx.AsyncClient() as client:
    async with client.stream('GET', url) as response:
        async for chunk in response.aiter_bytes(chunk_size=8192):
            # 处理数据块
            pass
```

---

**9. 文件上传**

```python
import httpx

# 简单文件上传
files = {'file': open('report.pdf', 'rb')}
response = httpx.post('https://api.example.com/upload', files=files)

# 指定文件名和类型
files = {
    'file': ('report.pdf', open('report.pdf', 'rb'), 'application/pdf')
}
response = httpx.post(url, files=files)

# 多文件上传
files = {
    'file1': open('doc1.pdf', 'rb'),
    'file2': open('doc2.pdf', 'rb'),
}
data = {'description': 'Multiple files'}
response = httpx.post(url, files=files, data=data)

# 异步上传
async with httpx.AsyncClient() as client:
    files = {'file': open('report.pdf', 'rb')}
    response = await client.post(url, files=files)
```

---

**10. 认证**

```python
import httpx

# HTTP 基础认证
auth = ('username', 'password')
response = httpx.get('https://api.example.com', auth=auth)

# Bearer Token
headers = {'Authorization': 'Bearer YOUR_TOKEN'}
response = httpx.get('https://api.example.com', headers=headers)

# 自定义认证
class TokenAuth(httpx.Auth):
    def __init__(self, token):
        self.token = token
    
    def auth_flow(self, request):
        request.headers['Authorization'] = f'Bearer {self.token}'
        yield request

auth = TokenAuth('YOUR_TOKEN')
response = httpx.get('https://api.example.com', auth=auth)
```

---

#### **实际应用场景**

**场景 1：统一的同步/异步 API 客户端**

```python
import httpx
import asyncio
from typing import Dict, Any

class UnifiedAPIClient:
    """同时支持同步和异步的 API 客户端"""
    
    def __init__(self, base_url: str, token: str):
        self.base_url = base_url
        self.headers = {'Authorization': f'Bearer {token}'}
        self._sync_client = None
        self._async_client = None
    
    @property
    def sync_client(self) -> httpx.Client:
        """延迟创建同步客户端"""
        if self._sync_client is None:
            self._sync_client = httpx.Client(
                base_url=self.base_url,
                headers=self.headers,
                timeout=30.0
            )
        return self._sync_client
    
    @property
    def async_client(self) -> httpx.AsyncClient:
        """延迟创建异步客户端"""
        if self._async_client is None:
            self._async_client = httpx.AsyncClient(
                base_url=self.base_url,
                headers=self.headers,
                timeout=30.0
            )
        return self._async_client
    
    # 同步方法
    def get_user(self, user_id: int) -> Dict[str, Any]:
        """同步获取用户"""
        response = self.sync_client.get(f'/users/{user_id}')
        response.raise_for_status()
        return response.json()
    
    def create_user(self, data: Dict) -> Dict[str, Any]:
        """同步创建用户"""
        response = self.sync_client.post('/users', json=data)
        response.raise_for_status()
        return response.json()
    
    # 异步方法
    async def get_user_async(self, user_id: int) -> Dict[str, Any]:
        """异步获取用户"""
        response = await self.async_client.get(f'/users/{user_id}')
        response.raise_for_status()
        return response.json()
    
    async def create_user_async(self, data: Dict) -> Dict[str, Any]:
        """异步创建用户"""
        response = await self.async_client.post('/users', json=data)
        response.raise_for_status()
        return response.json()
    
    async def get_many_users(self, user_ids: list[int]) -> list[Dict]:
        """并发获取多个用户"""
        tasks = [
            self.get_user_async(user_id)
            for user_id in user_ids
        ]
        return await asyncio.gather(*tasks)
    
    def close(self):
        """关闭客户端"""
        if self._sync_client:
            self._sync_client.close()
        if self._async_client:
            asyncio.run(self._async_client.aclose())

# 使用
client = UnifiedAPIClient('https://api.example.com', 'TOKEN')

# 同步使用
user = client.get_user(1)
print(user)

# 异步使用
async def main():
    users = await client.get_many_users([1, 2, 3, 4, 5])
    print(f"获取了 {len(users)} 个用户")

asyncio.run(main())
client.close()
```

---

**场景 2：重试和错误处理**

```python
import httpx
from tenacity import (
    retry,
    stop_after_attempt,
    wait_exponential,
    retry_if_exception_type
)

class ResilientClient:
    """带重试机制的客户端"""
    
    def __init__(self, base_url: str):
        self.client = httpx.Client(
            base_url=base_url,
            timeout=30.0,
        )
    
    @retry(
        stop=stop_after_attempt(3),
        wait=wait_exponential(multiplier=1, min=1, max=10),
        retry=retry_if_exception_type((
            httpx.ConnectError,
            httpx.ConnectTimeout,
        ))
    )
    def get_with_retry(self, url: str):
        """带重试的 GET 请求"""
        try:
            response = self.client.get(url)
            response.raise_for_status()
            return response.json()
        
        except httpx.HTTPStatusError as e:
            status = e.response.status_code
            
            # 特定状态码重试
            if status in {429, 500, 502, 503, 504}:
                print(f"状态码 {status}，重试中...")
                raise  # 触发重试
            
            # 其他状态码不重试
            print(f"请求失败: {status}")
            raise
    
    def close(self):
        self.client.close()

# 使用
client = ResilientClient('https://api.example.com')
try:
    data = client.get_with_retry('/unstable-endpoint')
    print(data)
finally:
    client.close()
```

---

**场景 3：代理和 SSL 配置**

```python
import httpx
import ssl

# 使用代理
proxies = {
    "http://": "http://proxy.example.com:8080",
    "https://": "http://proxy.example.com:8080",
}

client = httpx.Client(proxies=proxies)
response = client.get('https://api.example.com')

# 需要认证的代理
proxies = {
    "http://": "http://user:pass@proxy.example.com:8080",
}

# 自定义 SSL 配置
ssl_context = ssl.create_default_context()
# ssl_context.check_hostname = False
# ssl_context.verify_mode = ssl.CERT_NONE

client = httpx.Client(verify=ssl_context)

# 禁用 SSL 验证（不推荐）
client = httpx.Client(verify=False)
```

---

**常见陷阱**

**陷阱 1：忘记关闭客户端**

```python
# ❌ 错误：资源泄漏
client = httpx.Client()
response = client.get(url)
# 忘记 client.close()

# ✅ 正确：使用上下文管理器
with httpx.Client() as client:
    response = client.get(url)
# 自动关闭

# 异步也一样
async with httpx.AsyncClient() as client:
    response = await client.get(url)
```

---

**陷阱 2：混用同步和异步客户端**

```python
# ❌ 错误：在异步函数中使用同步客户端
async def bad():
    client = httpx.Client()  # 同步客户端
    response = client.get(url)  # 阻塞事件循环！

# ✅ 正确：使用异步客户端
async def good():
    async with httpx.AsyncClient() as client:
        response = await client.get(url)
```

---

**陷阱 3：没有设置超时**

```python
# ❌ 危险：可能永久挂起
response = httpx.get('https://slow-api.example.com')

# ✅ 安全：总是设置超时
response = httpx.get(
    'https://slow-api.example.com',
    timeout=10.0
)
```

---

#### **总结**

**核心优势**

| 优势         | 说明              |
| ------------ | ----------------- |
| **统一 API** | 同步/异步共享代码 |
| **HTTP/2**   | 更快的性能        |
| **类型提示** | 更好的 IDE 支持   |
| **现代设计** | 遵循最佳实践      |
| **易迁移**   | 兼容 requests API |

**最佳实践**

1. **使用上下文管理器** - 自动管理资源
2. **复用 Client** - 提高性能
3. **设置超时** - 防止挂起
4. **配置连接池** - 优化并发
5. **选择正确的客户端** - 同步/异步

---

## **Web 框架**

### 5.`uvicorn` - 服务器运行

**什么是 uvicorn？**

- **ASGI** (Async Server Gateway Interface) **服务器**

> - 三要素：scope（连接元数据），receive（接收事件协程），send（发送事件协程）。
> - 支持协议：HTTP/1.1、HTTP/2、WebSocket 等。
> - 支持并发与非阻塞 I/O，适合高并发场景。
> - 与 WSGI 的区别：WSGI 是同步、单请求-响应；ASGI 支持异步、长连接（WebSocket）、生命周期事件。

- 用于运行 **FastAPI**、**Starlette** 等异步 web 框架
- 基于 **uvloop** 和 **httptools**（高性能）
- AutoGPT Platform 的**主要 web 服务器**
- 需要安装：`pip install uvicorn`

**为什么用 uvicorn？**

```python
# 传统 WSGI 服务器（同步）
# gunicorn app:app  # Flask, Django

# uvicorn（异步，更快）
# uvicorn main:app --reload

# 优势：
# 1. 支持异步（async/await）
# 2. 高性能（比 gunicorn 快 2-3 倍）
# 3. 自动重载（开发模式）
# 4. WebSocket 支持
# 5. HTTP/2 支持（需要 h2）
```

---

#### **核心概念速查表**

| 概念                                                         | 作用         | 使用场景         |
| ------------------------------------------------------------ | ------------ | ---------------- |
| [uvicorn.run()](cci:1://file:///d:/%E8%BD%AC%E7%A0%81/AI-all/AutoGPT/autogpt_platform/backend/backend/data/block.py:439:4-461:84) | 编程方式启动 | 代码中启动       |
| `--reload`                                                   | 自动重载     | 开发环境         |
| `--workers`                                                  | 多进程       | 生产环境         |
| `--host`                                                     | 绑定地址     | 0.0.0.0 监听所有 |
| `--port`                                                     | 端口号       | 默认 8000        |
| `Config`                                                     | 配置对象     | 高级配置         |

---

> ## **AutoGPT Platform 中的实际使用**
>
> #### **案例 1：RPC 服务器（程序化启动）**
>
> ```python
> # backend/util/service.py
> import uvicorn
> from fastapi import FastAPI
> 
> class RPCService:
>     """RPC 服务基类"""
>     
>     def __start_fastapi(self):
>         """启动 FastAPI 服务器"""
>         logger.info(
>             f"Starting RPC server at http://{api_host}:{self.get_port()}"
>         )
>         
>         # 创建 uvicorn 服务器
>         server = uvicorn.Server(
>             uvicorn.Config(
>                 self.fastapi_app,            # FastAPI 应用
>                 host=api_host,               # 绑定地址
>                 port=self.get_port(),        # 端口
>                 log_config=None,             # 禁用 uvicorn 日志配置
>                 log_level=self.log_level,    # 日志级别
>             )
>         )
>         
>         # 在共享事件循环中运行
>         self.shared_event_loop.run_until_complete(server.serve())
>     
>     def run(self):
>         """主运行方法"""
>         # 创建 FastAPI 应用
>         self.fastapi_app = FastAPI()
>         
>         # 注册路由
>         self.fastapi_app.get("/health")(self.health_check)
>         
>         # 启动服务器（在单独线程中）
>         api_thread = threading.Thread(
>             target=self.__start_fastapi,
>             daemon=True
>         )
>         api_thread.start()
> ```
>
> ---
>
> #### **案例 2：REST API 服务器（性能优化）**
>
> ```python
> # backend/server/rest_api.py
> import uvicorn
> import platform
> 
> class AgentServer:
>     """Agent API 服务器"""
>     
>     def run(self):
>         # 配置 uvicorn（性能优化）
>         uvicorn_config = {
>             "app": server_app,
>             "host": config.agent_api_host,
>             "port": config.agent_api_port,
>             "log_config": None,
>             
>             # 性能优化
>             "http": "httptools",  # 使用 httptools 解析 HTTP
>             #       ^^^^^^^^^^^ 比标准库快 2-3 倍
>             
>             # 事件循环优化
>             "loop": "uvloop" if platform.system() != "Windows" else "auto",
>             #       ^^^^^^^ uvloop 比标准 asyncio 快 2-4 倍
>             #               但 Windows 不支持
>         }
>         
>         # 本地开发环境：启用调试
>         if config.app_env == AppEnvironment.LOCAL:
>             import os
>             os.environ["PYTHONASYNCIODEBUG"] = "1"
>         
>         # 启动服务器
>         uvicorn.run(**uvicorn_config)
> ```
>
> ---
>
> #### **案例 3：WebSocket 服务器（简单启动）**
>
> ```python
> # backend/server/ws_api.py
> import uvicorn
> from fastapi import FastAPI
> 
> class WebsocketServer:
>     """WebSocket 服务器"""
>     
>     def run(self):
>         # 简单启动
>         uvicorn.run(
>             server_app,
>             host=config.websocket_server_host,
>             port=config.websocket_server_port,
>             log_config=None,  # 使用自定义日志
>         )
>     
>     def cleanup(self):
>         """清理资源"""
>         logger.info("Shutting down WebSocket Server...")
> ```
>

#### 核心概念详解

**1. 命令行启动（开发环境）**

```bash
# 最简单的启动
uvicorn main:app

# 指定主机和端口
uvicorn main:app --host 0.0.0.0 --port 8000

# 自动重载（开发模式）
uvicorn main:app --reload
#                ^^^^^^^^ 代码修改自动重启

# 多进程（生产环境）
uvicorn main:app --workers 4
#                ^^^^^^^^^^^ 4 个工作进程

# 完整示例
uvicorn main:app \
  --host 0.0.0.0 \
  --port 8000 \
  --workers 4 \
  --log-level info \
  --access-log \
  --proxy-headers

# 使用配置文件
uvicorn main:app --config uvicorn_config.yaml
```

**main.py 示例：**
```python
from fastapi import FastAPI

app = FastAPI()

@app.get("/")
async def root():
    return {"message": "Hello World"}

# 运行：uvicorn main:app --reload
```

---

**2. 程序化启动（Python 代码）**

```python
import uvicorn
from fastapi import FastAPI

app = FastAPI()

@app.get("/")
async def root():
    return {"message": "Hello World"}

if __name__ == "__main__":
    # 方式 1：简单启动
    uvicorn.run(app, host="0.0.0.0", port=8000)
    
    # 方式 2：使用字符串（支持热重载）
    uvicorn.run(
        "main:app",
        host="0.0.0.0",
        port=8000,
        reload=True,  # 自动重载
        log_level="info"
    )
    
    # 方式 3：完整配置
    uvicorn.run(
        app,
        host="0.0.0.0",
        port=8000,
        workers=4,            # 多进程
        log_config=None,      # 禁用默认日志
        access_log=True,      # 访问日志
        proxy_headers=True,   # 代理头支持
        forwarded_allow_ips="*",  # 转发 IP
    )
```

---

**3. Config 对象（高级配置）**

```python
import uvicorn
from fastapi import FastAPI

app = FastAPI()

# 创建配置对象
config = uvicorn.Config(
    app=app,
    host="0.0.0.0",
    port=8000,
    
    # 日志配置
    log_level="info",
    log_config=None,  # 禁用 uvicorn 日志配置
    access_log=True,
    
    # 性能优化
    loop="uvloop",        # 使用 uvloop（Unix）
    http="httptools",     # 使用 httptools
    ws="websockets",      # WebSocket 实现
    
    # 多进程
    workers=4,
    
    # 其他
    reload=False,         # 生产环境禁用
    proxy_headers=True,   # 代理头
    server_header=False,  # 隐藏服务器头
    date_header=True,     # 日期头
)

# 创建并启动服务器
server = uvicorn.Server(config)
server.run()
```

---

**4. 在已有事件循环中运行**

> - **事件循环（Event Loop）**：asyncio 的核心，用于调度和执行异步任务。
> - **已有事件循环**：你的应用程序可能已经创建了一个 asyncio 事件循环，例如，你可能正在运行一个复杂的异步程序，其中包含多个并发任务。
> - **Uvicorn 默认行为**：通常，当你使用 `uvicorn.run()` 启动 Uvicorn 时，它会创建一个新的 asyncio 事件循环并在该循环中运行服务器。
> - **在已有事件循环中运行**：如果你想将 Uvicorn 集成到现有的异步程序中，你需要避免让 Uvicorn 创建新的事件循环。相反，你需要获取当前正在运行的事件循环，并将 Uvicorn 服务器配置为在该循环中运行。
>
> **为什么要在已有事件循环中运行 Uvicorn？**
>
> - **集成**：将 Uvicorn 集成到现有的异步应用程序中，避免创建多个事件循环导致的冲突。
> - **控制**：更精细地控制事件循环的行为，例如，自定义事件循环策略或与其他异步库集成。
> - **共享资源**：在同一个事件循环中运行多个异步组件，可以更方便地共享资源和状态。
>
> **如何实现？**
>
> 1. **获取当前事件循环**：使用 `asyncio.get_running_loop()` 获取当前正在运行的事件循环。
> 2. **创建 Uvicorn 服务器**：使用 `uvicorn.Server(config)` 创建 Uvicorn 服务器实例，并将 `config` 对象配置为使用现有的事件循环。
> 3. **运行服务器**：使用 `await server.serve()` 在当前事件循环中运行服务器。

```python
import asyncio
import uvicorn
from fastapi import FastAPI

app = FastAPI()

@app.get("/")
async def root():
    return {"message": "Hello"}

async def main():
    """在已有事件循环中运行 uvicorn"""
    config = uvicorn.Config(
        app=app,
        host="0.0.0.0",
        port=8000,
        log_config=None
    )
    server = uvicorn.Server(config)
    
    # 在当前事件循环中运行
    await server.serve()

# 运行
if __name__ == "__main__":
    asyncio.run(main())

# AutoGPT 的方式（共享事件循环）
class Service:
    def __init__(self):
        self.loop = asyncio.new_event_loop()
    
    def start_server(self):
        config = uvicorn.Config(app=app, host="0.0.0.0", port=8000)
        server = uvicorn.Server(config)
        # 在共享循环中运行
        self.loop.run_until_complete(server.serve())
```

---

**5. 性能优化配置**

```python
import uvicorn
import platform

# 生产环境最佳配置
config = uvicorn.Config(
    app=app,
    host="0.0.0.0",
    port=8000,
    
    # 多进程（CPU 核心数）
    workers=4,
    
    # 使用高性能库
    loop="uvloop" if platform.system() != "Windows" else "auto",
    #     ^^^^^^^ uvloop 比 asyncio 快 2-4 倍
    http="httptools",  # 更快的 HTTP 解析
    #     ^^^^^^^^^^ 比标准库快 2-3 倍
    ws="websockets",   # WebSocket 实现
    
    # 连接配置
    backlog=2048,           # 连接队列
    limit_concurrency=None,  # 无限制并发
    limit_max_requests=None, # 无限制请求数
    timeout_keep_alive=5,    # Keep-Alive 超时
    
    # 日志
    log_config=None,    # 使用自定义日志
    access_log=False,   # 生产环境禁用访问日志
    
    # 安全
    server_header=False,  # 隐藏服务器版本
)

server = uvicorn.Server(config)
server.run()
```

---

**6. 多进程部署**

```python
import uvicorn

# 方式 1：uvicorn 自带多进程
uvicorn.run(
    "main:app",
    host="0.0.0.0",
    port=8000,
    workers=4  # 4 个工作进程
)

# 方式 2：使用 gunicorn + uvicorn
# 命令行：
# gunicorn main:app -w 4 -k uvicorn.workers.UvicornWorker

# 方式 3：使用进程管理器
# systemd, supervisor, PM2 等
```

**gunicorn 配置文件（gunicorn.conf.py）：**
```python
import multiprocessing

# 服务器配置
bind = "0.0.0.0:8000"
workers = multiprocessing.cpu_count() * 2 + 1
worker_class = "uvicorn.workers.UvicornWorker"

# 日志
accesslog = "-"
errorlog = "-"
loglevel = "info"

# 性能
keepalive = 5
max_requests = 1000
max_requests_jitter = 50

# 优雅重启
graceful_timeout = 30
timeout = 30
```

---

**7. 自定义日志配置**

```python
import uvicorn
import logging

# 自定义日志格式
LOGGING_CONFIG = {
    "version": 1,
    "disable_existing_loggers": False,
    "formatters": {
        "default": {
            "format": "%(asctime)s - %(name)s - %(levelname)s - %(message)s",
        },
        "access": {
            "format": '%(asctime)s - %(client_addr)s - "%(request_line)s" %(status_code)s',
        },
    },
    "handlers": {
        "default": {
            "formatter": "default",
            "class": "logging.StreamHandler",
            "stream": "ext://sys.stdout",
        },
        "access": {
            "formatter": "access",
            "class": "logging.StreamHandler",
            "stream": "ext://sys.stdout",
        },
    },
    "loggers": {
        "uvicorn": {"handlers": ["default"], "level": "INFO"},
        "uvicorn.error": {"level": "INFO"},
        "uvicorn.access": {"handlers": ["access"], "level": "INFO"},
    },
}

# 使用自定义日志
uvicorn.run(
    app,
    host="0.0.0.0",
    port=8000,
    log_config=LOGGING_CONFIG
)

# AutoGPT 方式：禁用 uvicorn 日志
uvicorn.run(
    app,
    host="0.0.0.0",
    port=8000,
    log_config=None  # 使用应用自己的日志配置
)
```

---

#### **实际应用场景**

**场景 1：开发环境配置**

```python
# dev.py
import uvicorn
from fastapi import FastAPI

app = FastAPI()

@app.get("/")
async def root():
    return {"status": "dev"}

if __name__ == "__main__":
    uvicorn.run(
        "dev:app",  # 使用字符串以支持热重载
        host="127.0.0.1",
        port=8000,
        reload=True,          # 自动重载
        reload_dirs=["./"],   # 监控目录
        log_level="debug",    # 调试日志
    )
```

---

**场景 2：生产环境配置**

```python
# prod.py
import uvicorn
import platform
from fastapi import FastAPI

app = FastAPI()

if __name__ == "__main__":
    uvicorn.run(
        app,
        host="0.0.0.0",
        port=8000,
        workers=4,  # 多进程
        
        # 性能优化
        loop="uvloop" if platform.system() != "Windows" else "auto",
        http="httptools",
        
        # 生产配置
        reload=False,
        access_log=False,
        server_header=False,
        
        # 代理支持
        proxy_headers=True,
        forwarded_allow_ips="*",
    )
```

---

**场景 3：优雅关闭**

```python
import signal
import uvicorn
from fastapi import FastAPI

app = FastAPI()

@app.on_event("startup")
async def startup():
    print("服务启动...")

@app.on_event("shutdown")
async def shutdown():
    print("服务关闭...")
    # 清理资源
    await cleanup_resources()

class GracefulServer:
    def __init__(self):
        self.should_exit = False
        self.server = None
    
    def install_signal_handlers(self):
        """安装信号处理器"""
        signal.signal(signal.SIGINT, self.handle_exit)
        signal.signal(signal.SIGTERM, self.handle_exit)
    
    def handle_exit(self, sig, frame):
        """处理退出信号"""
        print(f"收到信号 {sig}，准备退出...")
        self.should_exit = True
        if self.server:
            self.server.should_exit = True
    
    def run(self):
        self.install_signal_handlers()
        
        config = uvicorn.Config(app, host="0.0.0.0", port=8000)
        self.server = uvicorn.Server(config)
        self.server.run()

if __name__ == "__main__":
    server = GracefulServer()
    server.run()
```

---

**场景 4：HTTPS 支持**

```python
import uvicorn
from fastapi import FastAPI

app = FastAPI()

if __name__ == "__main__":
    uvicorn.run(
        app,
        host="0.0.0.0",
        port=443,
        
        # SSL 配置
        ssl_keyfile="./key.pem",
        ssl_certfile="./cert.pem",
        
        # 可选：SSL 版本
        ssl_version=3,  # TLS 1.2
        ssl_cert_reqs=0,  # 不需要客户端证书
    )
```

---

**常见陷阱** 

**陷阱 1：开发环境用多进程**

> **单进程优点**：易于调试、支持自动重载、启动速度快、避免资源竞争。
>
> **多进程缺点**：调试困难、自动重载复杂、可能出现资源竞争、启动速度慢。
>
> - **自动重载（Hot Reloading）**：许多开发服务器（如 Uvicorn）提供的自动重载功能在单进程模式下工作得最好。当你修改代码时，服务器会自动检测到更改并重新启动，从而快速反映你的修改。在多进程模式下，实现自动重载会更加复杂，因为需要确保所有工作进程都正确地重新加载代码。
> - **调试**：单进程模式下，调试更加简单直接。你可以使用调试器逐步执行代码，并轻松地检查变量和状态。在多进程模式下，调试会变得更加困难，因为你需要同时跟踪多个进程的执行情况。
> - **资源竞争**：在开发环境中，你可能需要频繁地修改代码和重新启动服务器。如果使用多进程模式，可能会出现资源竞争的问题，例如端口冲突或文件锁定。
> - **启动速度**：单进程服务器通常比多进程服务器启动更快，这可以缩短开发周期。

```python
# ❌ 错误：开发环境用 workers
uvicorn.run(
    "main:app",
    reload=True,   # 热重载
    workers=4      # ❌ 不兼容！
)

# ✅ 正确：开发环境单进程
uvicorn.run(
    "main:app",
    reload=True,   # 只在单进程模式工作
)
```

---

**陷阱 2：Windows 上使用 uvloop**

> `uvloop` 是一个基于 libuv 的事件循环，它是 asyncio 的一个替代实现，主要为 Unix 系统设计，以提供更高的性能。

```python
# ❌ 错误：Windows 不支持 uvloop
uvicorn.run(app, loop="uvloop")  # ❌ RuntimeError

# ✅ 正确：检测操作系统
import platform

loop = "uvloop" if platform.system() != "Windows" else "auto"
uvicorn.run(app, loop=loop)
```

---

**陷阱 3：忘记绑定 0.0.0.0**

```python
# ❌ 错误：只能本地访问
uvicorn.run(app, host="127.0.0.1", port=8000)

# ✅ 正确：监听所有接口
uvicorn.run(app, host="0.0.0.0", port=8000)
```

---

#### **总结**

**核心配置**

| 参数      | 作用        | 推荐值                                 |
| --------- | ----------- | -------------------------------------- |
| `host`    | 绑定地址    | `0.0.0.0`（生产），`127.0.0.1`（开发） |
| `port`    | 端口号      | `8000`                                 |
| `workers` | 工作进程数  | CPU 核心数 × 2 + 1                     |
| `reload`  | 自动重载    | 开发：`True`，生产：`False`            |
| `loop`    | 事件循环    | `uvloop`（Unix），`auto`（Windows）    |
| `http`    | HTTP 解析器 | `httptools`                            |

**最佳实践**

1. **开发环境** - 使用 `--reload`
2. **生产环境** - 使用多进程和 uvloop
3. **日志管理** - 使用 `log_config=None` 自定义日志
4. **优雅关闭** - 处理 SIGTERM 信号
5. **代理部署** - 启用 `proxy_headers`

### 6.`websockets` - WebSocket 支持

**什么是 WebSocket？**

- **全双工**通信协议（客户端和服务器可以同时发送消息）
- 基于 **TCP** 的持久连接
- 适合**实时通信**（聊天、通知、实时更新）
- 比 HTTP 轮询更高效
- Python 实现：`websockets` 库（纯异步）

**为什么用 WebSocket？**

```python
# HTTP 轮询（低效）
while True:
    response = requests.get('/status')
    time.sleep(1)  # 每秒请求一次

# WebSocket（高效）
async with websockets.connect('ws://server') as ws:
    async for message in ws:
        print(message)  # 服务器推送即收到

# 优势：
# 1. 实时双向通信
# 2. 更低延迟
# 3. 更少带宽消耗
# 4. 持久连接
```

---

#### **核心概念速查表**

| 概念                                                         | 作用       | 使用场景              |
| ------------------------------------------------------------ | ---------- | --------------------- |
| [connect()](cci:1://file:///d:/%E8%BD%AC%E7%A0%81/AI-all/AutoGPT/autogpt_platform/backend/backend/data/db.py:55:0-70:71) | 客户端连接 | 连接 WebSocket 服务器 |
| `serve()`                                                    | 服务器端   | 创建 WebSocket 服务器 |
| `send()`                                                     | 发送消息   | 文本或二进制          |
| `recv()`                                                     | 接收消息   | 等待消息              |
| `async for`                                                  | 消息循环   | 持续接收              |
| [close()](cci:1://file:///d:/%E8%BD%AC%E7%A0%81/AI-all/AutoGPT/autogpt_platform/backend/backend/util/request.py:96:4-97:35) | 关闭连接   | 清理资源              |

---

> ## **AutoGPT Platform 中的实际使用**
>
> #### **案例 1：WebSocket 路由（FastAPI）**
>
> ```python
> # backend/server/ws_api.py
> from fastapi import FastAPI, WebSocket, WebSocketDisconnect
> 
> app = FastAPI()
> 
> @app.websocket("/ws")
> async def websocket_router(
>     websocket: WebSocket,
>     manager: ConnectionManager = Depends(get_connection_manager)
> ):
>     """WebSocket 主路由"""
>     # 1. 认证
>     user_id = await authenticate_websocket(websocket)
>     if not user_id:
>         return
>     
>     # 2. 接受连接
>     await manager.connect_socket(websocket)
>     
>     # 3. 跟踪连接数
>     update_websocket_connections(user_id, 1)
>     
>     try:
>         # 4. 消息循环
>         while True:
>             # 接收消息
>             data = await websocket.receive_text()
>             
>             # 解析消息
>             try:
>                 message = WSMessage.model_validate_json(data)
>             except pydantic.ValidationError as e:
>                 # 发送错误响应
>                 await websocket.send_text(
>                     WSMessage(
>                         method=WSMethod.ERROR,
>                         success=False,
>                         error="Invalid message format"
>                     ).model_dump_json()
>                 )
>                 continue
>             
>             # 处理消息
>             if message.method in _MSG_HANDLERS:
>                 await _MSG_HANDLERS[message.method](
>                     connection_manager=manager,
>                     websocket=websocket,
>                     user_id=user_id,
>                     message=message,
>                 )
>     
>     except WebSocketDisconnect:
>         # 5. 断开连接
>         manager.disconnect_socket(websocket)
>         logger.debug("WebSocket client disconnected")
>     
>     finally:
>         # 6. 清理
>         update_websocket_connections(user_id, -1)
> ```
>
> ---
>
> #### **案例 2：连接管理器**
>
> ```python
> # backend/server/conn_manager.py
> from fastapi import WebSocket
> from typing import Dict, Set
> 
> class ConnectionManager:
>     """WebSocket 连接管理器"""
>     
>     def __init__(self):
>         self.active_connections: Set[WebSocket] = set()
>         self.subscriptions: Dict[str, Set[WebSocket]] = {}
>     
>     async def connect_socket(self, websocket: WebSocket):
>         """接受新连接"""
>         await websocket.accept()
>         self.active_connections.add(websocket)
>     
>     def disconnect_socket(self, websocket: WebSocket):
>         """断开连接"""
>         self.active_connections.remove(websocket)
>         # 从所有订阅中移除
>         for subscribers in self.subscriptions.values():
>             subscribers.discard(websocket)
>     
>     async def subscribe_graph_exec(
>         self,
>         *,
>         user_id: str,
>         graph_exec_id: str,
>         websocket: WebSocket
>     ) -> str:
>         """订阅图执行更新"""
>         channel_key = f"{user_id}|graph_exec#{graph_exec_id}"
>         return await self._subscribe(channel_key, websocket)
>     
>     async def _subscribe(self, channel_key: str, websocket: WebSocket) -> str:
>         """内部订阅方法"""
>         if channel_key not in self.subscriptions:
>             self.subscriptions[channel_key] = set()
>         self.subscriptions[channel_key].add(websocket)
>         return channel_key
>     
>     async def send_execution_update(
>         self,
>         exec_event: GraphExecutionEvent
>     ) -> int:
>         """发送执行更新到所有订阅者"""
>         channel_key = f"{exec_event.user_id}|graph_exec#{exec_event.id}"
>         
>         subscribers = self.subscriptions.get(channel_key, set())
>         
>         message = WSMessage(
>             method=WSMethod.GRAPH_EXECUTION_EVENT,
>             data=exec_event.model_dump(),
>             success=True
>         ).model_dump_json()
>         
>         # 并发发送到所有订阅者
>         n_sent = 0
>         for ws in subscribers:
>             try:
>                 await ws.send_text(message)
>                 n_sent += 1
>             except Exception as e:
>                 logger.error(f"Error sending to WebSocket: {e}")
>         
>         return n_sent
> ```
>

#### 核心概念详解

**1. Fas tAPI WebSocket（最常用）**

```python
from fastapi import FastAPI, WebSocket, WebSocketDisconnect

app = FastAPI()

@app.websocket("/ws")
async def websocket_endpoint(websocket: WebSocket):
    """WebSocket 端点"""
    # 1. 接受连接
    await websocket.accept()
    
    try:
        # 2. 接收和发送消息
        while True:
            # 接收文本
            data = await websocket.receive_text()
            print(f"Received: {data}")
            
            # 发送响应
            await websocket.send_text(f"Echo: {data}")
    
    except WebSocketDisconnect:
        # 3. 客户端断开
        print("Client disconnected")

# 启动：uvicorn main:app
```

**客户端连接：**
```javascript
// JavaScript 客户端
const ws = new WebSocket('ws://localhost:8000/ws');

ws.onopen = () => {
    console.log('Connected');
    ws.send('Hello Server!');
};

ws.onmessage = (event) => {
    console.log('Received:', event.data);
};

ws.onclose = () => {
    console.log('Disconnected');
};
```

---

**2. 接收和发送消息**

```python
from fastapi import WebSocket

@app.websocket("/ws")
async def websocket_endpoint(websocket: WebSocket):
    await websocket.accept()
    
    try:
        # 接收文本消息
        text = await websocket.receive_text()
        
        # 接收二进制消息
        bytes_data = await websocket.receive_bytes()
        
        # 接收 JSON
        json_data = await websocket.receive_json()
        
        # 发送文本
        await websocket.send_text("Hello")
        
        # 发送二进制
        await websocket.send_bytes(b"binary data")
        
        # 发送 JSON
        await websocket.send_json({"message": "Hello"})
    
    except WebSocketDisconnect:
        pass
```

---

**3. 连接管理**

```python
from fastapi import WebSocket
from typing import List

class ConnectionManager:
    """管理多个 WebSocket 连接"""
    
    def __init__(self):
        self.active_connections: List[WebSocket] = []
    
    async def connect(self, websocket: WebSocket):
        """新连接"""
        await websocket.accept()
        self.active_connections.append(websocket)
    
    def disconnect(self, websocket: WebSocket):
        """断开连接"""
        self.active_connections.remove(websocket)
    
    async def send_personal_message(self, message: str, websocket: WebSocket):
        """发送给单个客户端"""
        await websocket.send_text(message)
    
    async def broadcast(self, message: str):
        """广播给所有客户端"""
        for connection in self.active_connections:
            await connection.send_text(message)

# 使用
manager = ConnectionManager()

@app.websocket("/ws/{client_id}")
async def websocket_endpoint(websocket: WebSocket, client_id: int):
    await manager.connect(websocket)
    
    try:
        while True:
            data = await websocket.receive_text()
            # 广播给所有人
            await manager.broadcast(f"Client #{client_id}: {data}")
    
    except WebSocketDisconnect:
        manager.disconnect(websocket)
        await manager.broadcast(f"Client #{client_id} left")
```

---

**4. 发布/订阅模式**

```python
from typing import Dict, Set

class PubSubManager:
    """发布/订阅管理器"""
    
    def __init__(self):
        self.subscriptions: Dict[str, Set[WebSocket]] = {}
    
    async def subscribe(self, channel: str, websocket: WebSocket):
        """订阅频道"""
        if channel not in self.subscriptions:
            self.subscriptions[channel] = set()
        self.subscriptions[channel].add(websocket)
    
    def unsubscribe(self, channel: str, websocket: WebSocket):
        """取消订阅"""
        if channel in self.subscriptions:
            self.subscriptions[channel].discard(websocket)
    
    async def publish(self, channel: str, message: str):
        """发布消息到频道"""
        if channel in self.subscriptions:
            for ws in self.subscriptions[channel]:
                try:
                    await ws.send_text(message)
                except Exception as e:
                    print(f"Error sending: {e}")

# 使用
manager = PubSubManager()

@app.websocket("/ws")
async def websocket_endpoint(websocket: WebSocket):
    await websocket.accept()
    
    try:
        while True:
            data = await websocket.receive_json()
            
            if data['action'] == 'subscribe':
                await manager.subscribe(data['channel'], websocket)
                await websocket.send_text(f"Subscribed to {data['channel']}")
            
            elif data['action'] == 'publish':
                await manager.publish(data['channel'], data['message'])
    
    except WebSocketDisconnect:
        # 清理所有订阅
        for subscribers in manager.subscriptions.values():
            subscribers.discard(websocket)
```

---

**5. 认证**

```python
from fastapi import WebSocket, Query, HTTPException

@app.websocket("/ws")
async def websocket_endpoint(
    websocket: WebSocket,
    token: str = Query(...)  # 从查询参数获取 token
):
    # 验证 token
    user = await authenticate_token(token)
    if not user:
        await websocket.close(code=1008, reason="Unauthorized")
        return
    
    await websocket.accept()
    
    try:
        while True:
            data = await websocket.receive_text()
            # 处理已认证用户的消息
            await websocket.send_text(f"Hello {user.name}")
    
    except WebSocketDisconnect:
        pass

# 客户端连接：
# ws://localhost:8000/ws?token=YOUR_TOKEN
```

---

**6. 心跳保活**

> **为什么需要心跳保活？**
>
> - **检测死连接**：及时发现已经断开的连接，避免资源浪费和数据不一致。
> - **维持连接**：某些网络设备或防火墙可能会关闭长时间空闲的连接。心跳消息可以防止连接被意外关闭。
> - **提高可靠性**：确保通信双方能够及时发现连接问题并采取相应的措施（例如重新连接）。
>
> **如何实现心跳保活？**
>
> 1. 客户端：
>    - 定期发送 ping 消息到服务器。
>    - 如果在一定时间内没有收到服务器的 pong 响应，则认为连接已断开，并尝试重新连接。
> 2. 服务器：
>    - 接收客户端的 ping 消息，并发送 pong 消息作为响应。
>    - 如果在一定时间内没有收到客户端的 ping 消息，则认为连接已断开，并关闭连接。

```python
import asyncio
from fastapi import WebSocket

@app.websocket("/ws")
async def websocket_endpoint(websocket: WebSocket):
    await websocket.accept()
    
    async def send_heartbeat():
        """定期发送心跳"""
        while True:
            try:
                await asyncio.sleep(30)  # 每 30 秒
                await websocket.send_json({"type": "ping"})
            except Exception:
                break
    
    # 启动心跳任务
    heartbeat_task = asyncio.create_task(send_heartbeat())
    
    try:
        while True:
            data = await websocket.receive_json()
            
            if data.get('type') == 'pong':
                # 收到心跳响应
                continue
            
            # 处理其他消息
            await websocket.send_json({"echo": data})
    
    except WebSocketDisconnect:
        heartbeat_task.cancel()
```

---

**7. 纯 websockets 库（不用 FastAPI）**

```python
import asyncio
import websockets

# 服务器端
async def echo(websocket, path):
    """WebSocket 处理器"""
    try:
        async for message in websocket:
            print(f"Received: {message}")
            await websocket.send(f"Echo: {message}")
    except websockets.exceptions.ConnectionClosed:
        print("Connection closed")

async def main():
    # 启动 WebSocket 服务器
    async with websockets.serve(echo, "localhost", 8765):
        print("WebSocket server started on ws://localhost:8765")
        await asyncio.Future()  # 永久运行

# 运行
asyncio.run(main())

# 客户端
async def client():
    uri = "ws://localhost:8765"
    async with websockets.connect(uri) as websocket:
        # 发送消息
        await websocket.send("Hello Server!")
        
        # 接收响应
        response = await websocket.recv()
        print(f"Received: {response}")

asyncio.run(client())
```

---

#### **实际应用场景**

**场景 1：聊天室**

```python
from fastapi import FastAPI, WebSocket, WebSocketDisconnect
from typing import List

app = FastAPI()

class ChatRoom:
    def __init__(self):
        self.connections: List[WebSocket] = []
    
    async def join(self, websocket: WebSocket, username: str):
        """加入聊天室"""
        await websocket.accept()
        self.connections.append(websocket)
        await self.broadcast(f"{username} joined the chat")
    
    def leave(self, websocket: WebSocket, username: str):
        """离开聊天室"""
        self.connections.remove(websocket)
        asyncio.create_task(
            self.broadcast(f"{username} left the chat")
        )
    
    async def broadcast(self, message: str):
        """广播消息"""
        for connection in self.connections:
            try:
                await connection.send_text(message)
            except Exception:
                pass

chat_room = ChatRoom()

@app.websocket("/chat/{username}")
async def chat_endpoint(websocket: WebSocket, username: str):
    await chat_room.join(websocket, username)
    
    try:
        while True:
            message = await websocket.receive_text()
            await chat_room.broadcast(f"{username}: {message}")
    
    except WebSocketDisconnect:
        chat_room.leave(websocket, username)
```

---

**场景 2：实时通知系统**

```python
from fastapi import FastAPI, WebSocket
import asyncio

app = FastAPI()

class NotificationManager:
    def __init__(self):
        self.user_connections: Dict[str, WebSocket] = {}
    
    async def connect(self, user_id: str, websocket: WebSocket):
        """用户连接"""
        await websocket.accept()
        self.user_connections[user_id] = websocket
    
    def disconnect(self, user_id: str):
        """用户断开"""
        self.user_connections.pop(user_id, None)
    
    async def notify_user(self, user_id: str, notification: dict):
        """通知特定用户"""
        ws = self.user_connections.get(user_id)
        if ws:
            try:
                await ws.send_json(notification)
            except Exception:
                self.disconnect(user_id)

manager = NotificationManager()

@app.websocket("/notifications/{user_id}")
async def notification_endpoint(websocket: WebSocket, user_id: str):
    await manager.connect(user_id, websocket)
    
    try:
        while True:
            # 保持连接活跃
            await websocket.receive_text()
    
    except WebSocketDisconnect:
        manager.disconnect(user_id)

# 从其他地方发送通知
@app.post("/send-notification")
async def send_notification(user_id: str, message: str):
    await manager.notify_user(user_id, {
        "type": "notification",
        "message": message
    })
    return {"status": "sent"}
```

---

**场景 3：实时数据流**

```python
from fastapi import FastAPI, WebSocket
import asyncio
import random

app = FastAPI()

@app.websocket("/stream")
async def stream_endpoint(websocket: WebSocket):
    """实时数据流"""
    await websocket.accept()
    
    try:
        while True:
            # 模拟实时数据
            data = {
                "timestamp": asyncio.get_event_loop().time(),
                "value": random.random(),
                "status": "active"
            }
            
            await websocket.send_json(data)
            await asyncio.sleep(1)  # 每秒发送一次
    
    except WebSocketDisconnect:
        print("Client disconnected from stream")
```

---

**常见陷阱**

**陷阱 1：忘记 accept**

```python
# ❌ 错误：忘记 accept
@app.websocket("/ws")
async def bad_endpoint(websocket: WebSocket):
    # 没有 accept！
    await websocket.send_text("Hello")  # ❌ 连接未建立

# ✅ 正确：先 accept
@app.websocket("/ws")
async def good_endpoint(websocket: WebSocket):
    await websocket.accept()  # ✅ 先接受连接
    await websocket.send_text("Hello")
```

---

**陷阱 2：不处理断开**

```python
# ❌ 错误：不捕获断开异常
@app.websocket("/ws")
async def bad_endpoint(websocket: WebSocket):
    await websocket.accept()
    while True:
        data = await websocket.receive_text()
        # 客户端断开会抛出异常，未处理！

# ✅ 正确：捕获 WebSocketDisconnect
@app.websocket("/ws")
async def good_endpoint(websocket: WebSocket):
    await websocket.accept()
    try:
        while True:
            data = await websocket.receive_text()
    except WebSocketDisconnect:
        print("Client disconnected")
```

---

**陷阱 3：阻塞事件循环**

```python
# ❌ 错误：阻塞操作
@app.websocket("/ws")
async def bad_endpoint(websocket: WebSocket):
    await websocket.accept()
    while True:
        data = await websocket.receive_text()
        result = expensive_sync_operation()  # ❌ 阻塞！
        await websocket.send_text(result)

# ✅ 正确：使用异步或线程池
@app.websocket("/ws")
async def good_endpoint(websocket: WebSocket):
    await websocket.accept()
    while True:
        data = await websocket.receive_text()
        # 在线程池中执行
        result = await asyncio.to_thread(expensive_sync_operation)
        await websocket.send_text(result)
```

---

#### **总结**

**核心概念**

| 概念                                                         | 作用     | 关键点     |
| ------------------------------------------------------------ | -------- | ---------- |
| `accept()`                                                   | 接受连接 | 必须先调用 |
| `receive_text()`                                             | 接收消息 | 异步等待   |
| `send_text()`                                                | 发送消息 | 异步发送   |
| `WebSocketDisconnect`                                        | 断开异常 | 必须处理   |
| [ConnectionManager](cci:2://file:///d:/%E8%BD%AC%E7%A0%81/AI-all/AutoGPT/autogpt_platform/backend/backend/server/conn_manager.py:17:0-106:19) | 管理连接 | 广播、订阅 |

**最佳实践**

1. **总是 accept** - 建立连接前先接受
2. **捕获断开** - 处理 WebSocketDisconnect
3. **连接管理** - 使用管理器跟踪连接
4. **心跳保活** - 定期 ping/pong
5. **错误处理** - 发送时捕获异常

